
Mientras HTML y CSS controlan el contenido y el estilo de una página, JavaScript se utiliza para hacerlo interactivo. En la certificación Algoritmos de JavaScript y Estructuras de Datos, aprenderás los fundamentos de JavaScript incluyendo variables, arreglos, objetos, bucles y funciones.

Una vez que tengas los fundamentos, aplicarás ese conocimiento creando algoritmos para manipular cadenas, factorizar números e incluso calcular la órbita de la Estación Espacial Internacional.

A lo largo del camino, también aprenderás dos estilos o paradigmas importantes de programación: la Programación Orientada a Objetos (OOP), y la Programación Funcional (FP).
-----------
Comenta tu código de JavaScript
Declara variables de JavaScript
Almacenar valores con el operador de asignación
Asigna el valor de una variable a otra variable
Inicializa variables con el operador de asignación
Declara variables de cadena
Comprendiendo las variables no inicializadas
Comprendiendo la sensibilidad de mayúsculas en las variables
Explora las diferencias entre las palabras claves var y let
Declara una variable de solo lectura con la palabra clave const
Suma dos números con JavaScript
Resta un número de otro con JavaScript
Multiplica dos números con JavaScript
Divide un número entre otro con JavaScript
Incrementa un número con JavaScript
Decrementa un número con JavaScript
Crea números decimales con JavaScript
Multiplica dos números decimales con JavaScript
Divide un decimal entre otro con JavaScript
Encuentra un resto en JavaScript
Asignación compuesta con adición aumentada
Asignación compuesta con resta aumentada
Asignación compuesta con multiplicación aumentada
Asignación compuesta con división aumentada
Escapa comillas literales en cadenas
Cita cadenas con comillas simples
Escapa secuencias en cadenas
Concatena cadenas con el operador "más"
Concatena cadenas con el operador "más igual"
Construye cadenas con variables
Agrega variables a cadenas
Encuentra la longitud de una cadena
Utiliza la notación de corchetes para encontrar el primer carácter en una cadena
Comprende la inmutabilidad de las cadenas
Utiliza la notación de corchetes para encontrar el enésimo carácter en una cadena
Utiliza la notación de corchetes para encontrar el último carácter en una cadena
Utiliza la notación de corchetes para encontrar el carácter enésimo final en una cadena
Palabra en blanco
Almacena múltiples valores en una variable utilizando los arreglos de JavaScript
Anida un arreglo dentro de otro arreglo
Accede a los datos de un arreglo con índices
Modifica los datos de un arreglo con índices
Accede a arreglos multidimensionales con índices
Manipula arreglos con push()
Manipula arreglos con pop()
Manipula arreglos con shift()
Manipula arreglos con unshift()
Lista de compras
Escribe JavaScript reutilizable utilizando funciones
Pasa valores a las funciones utilizando argumentos
Devuelve un valor de una función utilizando "Return"
Ámbito global y funciones
Ámbito local y funciones
Ámbito global vs. local en funciones
Comprendiendo el valor indefinido devuelto por una función
Asignación con un valor devuelto
Permanece en línea
Comprende los valores booleanos
Usa lógica condicional con las sentencias "If"
Comparación con el operador de igualdad
Comparación con el operador de estricta igualdad
Practica comparando diferentes valores
Comparación con el operador de desigualdad
Comparación con el operador de estricta desigualdad
Comparación con el operador "mayor que"
Comparación con el operador "mayor o igual que"
Comparación con el operador "menor que"
Comparación con el operador "menor o igual que"
Comparaciones con el operador lógico "and"
Comparaciones con el operador lógico "or"
Introducción a las sentencias "Else"
Introducción a las sentencias "Else If"
Orden lógico de las sentencias "if else"
Encadena sentencias if else
Código de golf
Seleccionando entre muchas opciones con declaración switch
Agrega una opción predeterminada en las declaraciones switch
Múltiples opciones idénticas en las declaraciones "switch"
Reemplazando cadenas de "If Else" por "Switch"
Devuelve valores booleanos desde funciones
Patrón de devolución anticipado para funciones
Conteo de cartas
Construye objetos en JavaScript
Accede a propiedades de objetos con notación de puntos
Accede a propiedades de objetos con notación de corchete
Accede a propiedades de objetos con variables
Actualizando las propiedades de un objeto
Añade nuevas propiedades a un objeto de JavaScript
Elimina propiedades en un objeto de JavaScript
Usa objetos para hacer búsquedas
Verifica las propiedades de un objeto
Manipulando objectos complejos
Accede a objetos anidados
Accede a arreglos anidados
Colección de discos
Itera con el bucle "while" de JavaScript
Itera con los bucles "for" de JavaScript
Itera números impares con un bucle "for"
Cuenta hacia atrás con un bucle "for"
Itera a través de un arreglo con un bucle "for"
Anida bucles "for"
Itera con el bucle "do...while" de JavaScript
Reemplaza bucles usando recursión
Búsqueda de perfiles
Genera fracciones aleatorias con JavaScript
Genera números enteros aleatorios con JavaScript
Genera números enteros aleatorios dentro de un rango
Utiliza la función "parseInt"
Utiliza la función "parseInt" con Radix (Base)
Usa el operador condicional (ternario)
Usa múltiples operadores condicionales (ternarios)
Utiliza recursión para crear una cuenta regresiva
Usa recursión para crear un rango de números

-----------
JavaScript básico
-----------
Algoritmos de JavaScript y Estructuras de Datos
Mientras HTML y CSS controlan el contenido y el estilo de una página, JavaScript se utiliza para hacerlo interactivo. En la certificación Algoritmos de JavaScript y Estructuras de Datos, aprenderás los fundamentos de JavaScript incluyendo variables, arreglos, objetos, bucles y funciones.

Una vez que tengas los fundamentos, aplicarás ese conocimiento creando algoritmos para manipular cadenas, factorizar números e incluso calcular la órbita de la Estación Espacial Internacional.

A lo largo del camino, también aprenderás dos estilos o paradigmas importantes de programación: la Programación Orientada a Objetos (OOP), y la Programación Funcional (FP).

Nota: Algunas extensiones del navegador, como bloqueadores de anuncios o bloqueadores de scripts pueden interferir con las pruebas. Si se te presentan problemas, te recomendamos deshabilitar las extensiones que modifiquen o bloqueen el contenido de la página, mientras tomas el curso.
Cursos
JavaScript básico
JavaScript es un lenguaje de scripting que puedes utilizar para hacer que las páginas web sean interactivas. Es una de las principales tecnologías de la web, junto con HTML y CSS, y es soportada por todos los navegadores modernos.

En este curso, aprenderás conceptos fundamentales de programación en JavaScript. Empezarás con estructuras básicas de datos como números y cadenas. Luego aprenderás a trabajar con arreglos, objetos, funciones, bucles, declaraciones if/else y más.
---------
Comenta tu código de JavaScript
Los comentarios son líneas de código que JavaScript ignorará intencionalmente. Los comentarios son una gran manera de dejar notas para ti mismo y a otras personas que más tarde tengan que averiguar qué hace ese código.

Hay dos maneras de escribir comentarios en JavaScript:

Usar // le dirá a JavaScript que ignore el resto del texto en la línea actual. Este es un comentario en línea:

// This is an in-line comment.
Puedes hacer un comentario multilínea comenzando con /* y terminando con */. Este es un comentario multilínea:

/* This is a
multi-line comment */
**Nota: ** A medida que programas, deberías añadir comentarios regularmente para aclarar el funcionamiento de las partes de tu código. Un buen comentario puede ayudar a comunicar la intención de tu código, tanto para otros como para tu yo futuro.

Intenta crear un comentario de cada tipo.
-------------------
Un bucle para gobernarlos a todos.
-------
Declara variables de JavaScript
En informática, los datos son cualquier cosa que tenga sentido para la computadora. JavaScript proporciona ocho tipos de datos diferentes, los cuales son undefined, null, boolean, string, symbol, bigint, number, y object.

Por ejemplo, las computadoras distinguen entre números, como el número 12 y cadenas (strings), tales como "12", "dog", o "123 cats", que son colecciones de caracteres. Las computadoras pueden realizar operaciones matemáticas en un número, pero no en una cadena.

Las variables permiten a los ordenadores almacenar y manipular datos de forma dinámica. Hacen esto usando una "etiqueta" para apuntar a los datos en lugar de usar los datos en sí. Cualquiera de los ocho tipos de datos puede almacenarse en una variable.

Las variables son similares a las variables x, e y que usan en matemáticas, lo que significa que son un nombre simple para representar los datos a los que queremos hacer referencia. Las variables de computadora difieren de las variables matemáticas en que pueden almacenar diferentes valores en diferentes momentos.

Le decimos a JavaScript que cree o declare una variable poniendo la palabra clave var delante de ella, así:

var ourName;
crea una variable llamada ourName. En JavaScript terminamos las sentencias con punto y coma. Los nombres de las variables pueden estar formados por números, letras y $ o _, pero no pueden contener espacios ni empezar con un número.

Utiliza la palabra clave var para crear una variable llamada myName.

Sugerencia
Mira el ejemplo ourName de arriba si te quedas atascado.
--------------
¡Siente la velocidad!
----------
Almacenar valores con el operador de asignación
En JavaScript, puedes almacenar un valor en una variable con el operador de asignación (=).

myVariable = 5;
Esto asigna el valor numérico (Number) 5 a myVariable.

Si hay algunos cálculos a la derecha del operador =, se realizan antes de que el valor se asigne a la variable a la izquierda del operador.

var myVar;
myVar = 5;
Primero, este código crea una variable llamada myVar. Luego, el código asigna 5 a myVar. Ahora, si myVar aparece de nuevo en el código, el programa lo tratará como si fuera 5.

Asigna el valor 7 a la variable a.
-----------
¡Lo tienes!
----------
Asigna el valor de una variable a otra variable
Después de asignar un valor a una variable usando el operador de asignación, puedes asignar el valor de esa variable a otra variable usando el mismo operador de asignación.

var myVar;
myVar = 5;
var myNum;
myNum = myVar;
Lo anterior declara una variable myVar sin valor, y luego le asigna el valor 5. A continuación, una variable llamada myNum es declarada, tambien sin valor. Luego, el contenido de myVar (que es 5) se asigna a la variable myNum. Ahora, myNum también tiene el valor de 5.

Asigna el contenido de a a la variable b.
------------
¡Eres un mago, Harry!
----------
Inicializa variables con el operador de asignación
Es común inicializar una variable a un valor inicial en la misma línea que es declarada.

var myVar = 0;
Crea una nueva variable llamada myVar y le asigna un valor inicial de 0.

Define una variable a con var e inicialízala con un valor de 9
-------
¡Velocidad ridícula!
-------
Declara variables de cadena
Anteriormente utilizaste el siguiente código para declarar una variable:

var myName;
Pero también puedes declarar una variable de cadena como esta:

var myName = "your name";
"your name" es llamada una cadena literal. Una cadena literal o cadena es una serie de ceros o más caracteres encerrados en comillas simples o dobles.

Crea dos nuevas variables de cadena: myFirstName y myLastName y asígnales los valores de tu nombre y apellido, respectivamente.
-------
¡Récord de juego!
------
Cuando las variables de JavaScript son declaradas, tienen un valor inicial de undefined (indefinido). Si haces una operación matemática en una variable undefined, tu resultado será NaN lo que significa "Not a Number" (no es un número). Si concatenas una cadena con una variable undefined, obtendrás una cadena de undefined.

Inicializa las tres variables a, b, y c con 5, 10 y "I am a" respectivamente para que no sean undefined.
--------
¡La cuchara no existe, Neo!
-------
Comprendiendo la sensibilidad de mayúsculas en las variables
En JavaScript todas las variables y nombres de función son sensibles a mayúsculas y minúsculas. Esto significa que la capitalización importa.

MYVAR no es lo mismo que MyVar ni myvar. Es posible tener múltiples variables distintas con el mismo nombre pero diferente capitalización. Se recomienda encarecidamente que por el bien de la claridad, no utilices esta funcionalidad del lenguaje.

Buena Práctica

Escribe los nombres de las variables en JavaScript en camelCase. En camelCase, los nombres de variables de múltiples palabras tienen la primera palabra en minúsculas y la primera letra de cada palabra posterior en mayúsculas.

Ejemplos:

var someVariable;
var anotherVariableName;
var thisVariableNameIsSoLong;
Modifica las declaraciones y asignaciones existentes para que sus nombres usen camelCase.

No crees ninguna variable nueva.
-----
¡Siente la velocidad!
-----
Explora las diferencias entre las palabras claves var y let
Uno de los mayores problemas con la declaración de variables utilizando la palabra clave var es que tú puedes fácilmente sobrescribir declaraciones de variables:

var camper = "James";
var camper = "David";
console.log(camper);
En el código anterior, la variable camper se declara originalmente como James, y se anula para ser David. La consola después muestra la cadena de texto David.

En una aplicación pequeña, tal vez no te encuentres con este tipo de problema. Pero a medida que tu código base se hace más grande, puedes ser que accidentalmente sobrescribas una variable que no tenías la intención de hacer. Debido a que este comportamiento no causa un error, la búsqueda y corrección de errores se vuelve más difícil.

Una palabra clave llamada let fue introducida en ES6, una actualización importante para JavaScript, para resolver este problema potencial con la palabra clave var. Aprenderás sobre otras características de ES6 en desafíos posteriores.

Si reemplazas var por let en el código anterior, resultará en un error:

let camper = "James";
let camper = "David";
El error se puede ver en tu consola de tu navegador.

Así que a diferencia de var, al usar let, una variable con el mismo nombre solo puede declararse una vez.

Actualiza el código para que solo utilice la palabra clave let.
--------
¿Qué clase de brujería es esta?
-------
Declara una variable de solo lectura con la palabra clave const
La palabra clave let no es la única manera nueva de declarar variables. En ES6, tú también puedes declarar variables usando la palabra clave const.

const tiene todas las características increíbles que tiene let, con el bono añadido de que las variables declaradas usando const son de solo lectura. Son un valor constante, lo que significa que una vez que una variable es asignada con const, no se puede reasignar:

const FAV_PET = "Cats";
FAV_PET = "Dogs";
La consola mostrará un error debido a la reasignación del valor de FAV_PET.

Siempre debes nombrar variables que no quieras reasignar usando la palabra clave const. Esto ayuda cuando intentas reasignar accidentalmente una variable que está destinada a permanecer constante.

Nota: Es común que los desarrolladores usen identificadores de variables en mayúsculas para valores inmutables y minúsculas o camelCase para valores mutables (objetos y arreglos). Aprenderás más sobre objetos, arreglos y valores inmutables y mutables en desafíos posteriores. También en desafíos posteriores, verás ejemplos de identificadores de variables mayúsculas, minúsculas o camelCase.

Cambia el código para que todas las variables se declaren con let o const. Usa let cuando quieras que la variable cambie y const cuando quieras que la variable permanezca constante. Además, renombra variables declaradas con const para adaptarse a las prácticas comunes. No debes cambiar las palabras asignadas a las variables
----
Declara una variable de solo lectura con la palabra clave const
La palabra clave let no es la única manera nueva de declarar variables. En ES6, tú también puedes declarar variables usando la palabra clave const.

const tiene todas las características increíbles que tiene let, con el bono añadido de que las variables declaradas usando const son de solo lectura. Son un valor constante, lo que significa que una vez que una variable es asignada con const, no se puede reasignar:

const FAV_PET = "Cats";
FAV_PET = "Dogs";
La consola mostrará un error debido a la reasignación del valor de FAV_PET.

Siempre debes nombrar variables que no quieras reasignar usando la palabra clave const. Esto ayuda cuando intentas reasignar accidentalmente una variable que está destinada a permanecer constante.

Nota: Es común que los desarrolladores usen identificadores de variables en mayúsculas para valores inmutables y minúsculas o camelCase para valores mutables (objetos y arreglos). Aprenderás más sobre objetos, arreglos y valores inmutables y mutables en desafíos posteriores. También en desafíos posteriores, verás ejemplos de identificadores de variables mayúsculas, minúsculas o camelCase.

Cambia el código para que todas las variables se declaren con let o const. Usa let cuando quieras que la variable cambie y const cuando quieras que la variable permanezca constante. Además, renombra variables declaradas con const para adaptarse a las prácticas comunes. No debes cambiar las palabras asignadas a las variables.
------
¡Nunca bajes la guardia!
------
Suma dos números con JavaScript
Number (número) es un tipo de datos en JavaScript que representa datos numéricos.

Ahora intentemos sumar dos números usando JavaScript.

JavaScript utiliza el símbolo + como un operador de adición cuando se coloca entre dos números.

Ejemplo:

const myVar = 5 + 10;
myVar ahora tiene el valor 15.

Cambia el 0 para que la suma sea igual a 20.
---------
Está vivo. ¡Está vivo!
--------
Resta un número de otro con JavaScript
También podemos restar un número de otro.

JavaScript utiliza el símbolo - para restar.

Ejemplo

const myVar = 12 - 6;
myVar tendrá el valor 6.

Cambia el 0 para que la diferencia sea 12.
--------
¡Corre como el viento!
--------
Multiplica dos números con JavaScript
También podemos multiplicar un número por otro.

JavaScript utiliza el símbolo * para multiplicar dos números.

Ejemplo

const myVar = 13 * 13;
myVar ahora tendrá el valor 169.

Cambia el 0 para que el producto sea igual a 80
------
¡Estás en llamas!
------
Divide un número entre otro con JavaScript
También podemos dividir un número entre otro.

JavaScript utiliza el símbolo / para la división.

Ejemplo

const myVar = 16 / 2;
myVar ahora tiene el valor 8.

Cambia el 0 para que el quotient (cociente) sea igual a 2.
-----------
Programa mucho y prospera
----------
Incrementa un número con JavaScript
Puedes fácilmente incrementar o sumar uno a una variable con el operador ++.

i++;
es equivalente a

i = i + 1;
Nota: Toda la línea se convierte en i++;, eliminando la necesidad del signo de igualdad.

Cambia el código para usar el operador ++ en myVar
------
¡Súper combo!
-----
Decrementa un número con JavaScript
Puedes fácilmente decrementar o disminuir una variable por uno utilizando el operador --.

i--;
es el equivalente de

i = i - 1;
Nota: La linea se convierte en i--;, eliminando la necesidad del signo igual.

Cambia el código para usar el operador -- en myVar.
-------
El Nirvana está llegando, el portal místico espera
------
Crea números decimales con JavaScript
También podemos almacenar números decimales en variables. Los números decimales a veces se denominan números de coma flotante o flotantes.

Nota: computadoras representan números con precisión finita. Por eso las operaciones de punto flotante no pueden representar exactamente verdaderas operaciones aritméticas, y esto conduce a muchas situaciones sorprendentes. si te enfrentas con uno de estos problemas, abre el tema en el foro de freeCodeCamp.

Crea una variable myDecimal y dale un valor decimal con una parte fraccional (por ejemplo, 5.7)
------
¡Nunca bajes la guardia!
-----
Multiplica dos números decimales con JavaScript
En JavaScript, también puedes realizar cálculos con números decimales, al igual que con números enteros.

Multipliquemos dos números decimales para obtener su producto.

Cambia el 0.0 para que el producto sea igual a 5.0.
-------
¡Haz que llueva!
------
Divide un decimal entre otro con JavaScript
Ahora dividamos un decimal entre otro.

Cambia el 0.0 para que el cociente (quotient) sea igual a 2.2.
-------
¿Nivel de poder? ¡Supera los 9000!
------
Encuentra un resto en JavaScript
El operador de resto % entrega el resto de la división entre dos números.

Ejemplo

5 % 2 = 1 porque
Math.floor(5 / 2) = 2 (Cociente)
2 * 2 = 4
5 - 4 = 1 (Resto)
Uso
En matemáticas, un número se puede comprobar para saber si es par o impar revisando el resto de la división del número por 2.

17 % 2 = 1 (17 es impar)
48 % 2 = 0 (48 es par)
Nota: El operador de resto es a veces incorrectamente referido como el operador módulo. Es muy similar al módulo, pero no funciona adecuadamente con números negativos.

Establece remainder igual al resto de 11 dividido entre 3 usando el operador de resto (%).
--------
¡Lo tienes!
-------
Asignación compuesta con adición aumentada
En la programación, es común utilizar asignaciones para modificar el contenido de una variable. Recuerda que todo lo que está a la derecha del signo de igualdad se evalúa primero, así que podemos decir:

myVar = myVar + 5;
para sumar 5 a myVar. Dado que se trata de un patrón tan común, hay operadores que hacen tanto la operación matemática como la asignación en un solo paso.

Uno de estos operadores es el operador +=.

let myVar = 1;
myVar += 5;
console.log(myVar);
Se mostrará un 6 en la consola.

Convierte las asignaciones de a, b y c para que utilicen el operador +=.
------------
¡Eres imparable!
-----------
Asignación compuesta con resta aumentada
Al igual que el operador +=, -= resta un número de una variable.

		myVar = myVar - 5;
le restara 5 de myVar. Esto se puede reescribir como:

myVar -= 5;
Convierte las tareas de a, b, y c para utilizar el operador -=.
--------
¡Velocidad ridícula!
-------
Asignación compuesta con multiplicación aumentada
El operador *= multiplica una variable por un número.

myVar = myVar * 5;
se multiplicará myVar por 5. Esto se puede reescribir como:

myVar *= 5;
Convierte las tareas de a, b, y c para utilizar el operador *=.
---------
¡La estás rompiendo!
--------
Asignación compuesta con división aumentada
El operador /= divide una variable entre otro número.

myVar = myVar / 5;
Dividirá myVar por 5. Esto se puede reescribir como:

myVar /= 5;
Convierte las tareas de a, b, y c para utilizar el operador /=.
---------
¡Legen... aguarda... dario!
-------
Escapa comillas literales en cadenas
Cuando estás definiendo una cadena debes comenzar y terminar con una comilla simple o doble. ¿Qué pasa cuando necesitas una comilla literal: " o ' dentro de tu cadena?

En JavaScript, puedes escapar una comilla de considerarse un final de cadena colocando una barra invertida (\) delante de la comilla.

const sampleStr = "Alan said, \"Peter is learning JavaScript\".";
Esto indica a JavaScript que la siguiente comilla no es el final de la cadena, sino que debería aparecer dentro de la cadena. Así que si imprimieras esto en la consola, obtendrías:

Alan said, "Peter is learning JavaScript".
Usa barras invertidas para asignar una cadena a la variable myStr de modo que si lo imprimieras en la consola, verías:

I am a "double quoted" string inside "double quotes".
-----------
consejos para aprender javascript.
-aprender vanilla javascript(javascript puro no framewords ni bibliotecas).
-busca en MDN web docs y w3schools.
-pregunta en stack overflow.
-utiliza la consola f12.

javascript ES6 o ES2015
es el lenguaje de programacion mas importante en la actualidad.
-ECMAScript
------------
Escapa comillas literales en cadenas
Cuando estás definiendo una cadena debes comenzar y terminar con una comilla simple o doble. ¿Qué pasa cuando necesitas una comilla literal: " o ' dentro de tu cadena?

En JavaScript, puedes escapar una comilla de considerarse un final de cadena colocando una barra invertida (\) delante de la comilla.

const sampleStr = "Alan said, \"Peter is learning JavaScript\".";
Esto indica a JavaScript que la siguiente comilla no es el final de la cadena, sino que debería aparecer dentro de la cadena. Así que si imprimieras esto en la consola, obtendrías:

Alan said, "Peter is learning JavaScript".
Usa barras invertidas para asignar una cadena a la variable myStr de modo que si lo imprimieras en la consola, verías:

I am a "double quoted" string inside "
-------------
¡A buen paso dale prisa!
-----------
Cita cadenas con comillas simples
Los valores de cadena en JavaScript pueden escribirse con comillas simples o dobles, siempre y cuando comiencen y terminen con el mismo tipo de comillas. A diferencia de otros lenguajes de programación, las comillas simples y dobles funcionan igual en JavaScript.

const doubleQuoteStr = "This is a string"; 
const singleQuoteStr = 'This is also a string';
La razón por la que puedes querer usar un tipo de comilla sobre otro es si quieres usar ambos en una cadena. Esto puede suceder si quieres guardar una conversación en una cadena y tener la conversación entre comillas. Otro uso sería guardar una etiqueta <a> con varios atributos entre comillas, todo dentro de una cadena.

const conversation = 'Finn exclaims to Jake, "Algebraic!"';
Sin embargo, esto se convierte en un problema cuando es necesario utilizar las comillas externas dentro de ella. Recuerda, una cadena tiene el mismo tipo de comillas al principio y al final. Pero si tienes esa misma comilla en algún lugar del medio, la cadena se detendrá antes de tiempo y arrojará un error.

const goodStr = 'Jake asks Finn, "Hey, let\'s go on an adventure?"'; 
const badStr = 'Finn responds, "Let's go!"';
Aquí badStr arrojará un error.

En la cadena goodStr anterior, puedes usar ambas comillas de forma segura usando la barra invertida \ como un carácter de escape.

Nota: La barra invertida \ no debe confundirse con la barra diagonal /. No hacen lo mismo.

Cambia la cadena proporcionada a una cadena con comillas simples al principio y al final y sin caracteres de escape.

Ahora mismo, la etiqueta <a> en la cadena usa comillas dobles en todas partes. Necesitarás cambiar las comillas externas a comillas simples para poder eliminar los caracteres de escape.
-------------
¡Corre como el viento!
----------
Escapa secuencias en cadenas
Las comillas no son los únicos caracteres que pueden ser escapados dentro de una cadena. Hay dos razones para usar caracteres de escape:

Para permitir el uso de caracteres que de otra manera no te sería posible escribir, como un retorno de carro.
Para permitirte representar múltiples comillas en una cadena sin que JavaScript malinterprete lo que quieres decir.
Esto lo aprendimos en el desafío anterior.

Código	Resultado
\'	comilla simple
\"	comilla doble
\\	barra invertida
\n	línea nueva
\r	retorno de carro
\t	tabulación
\b	límite de palabra
\f	fuente de formulario
Ten en cuenta que la barra invertida en sí debe ser escapada para poder mostrarla como una barra invertida.

Asigna las siguientes tres líneas de texto en la variable única myStr usando secuencias de escape.

FirstLine
    \SecondLine
ThirdLine
Necesitarás usar secuencias de escape para insertar correctamente los caracteres especiales. También necesitarás seguir el espaciado tal y como se ve arriba, sin espacios entre secuencias de escape o palabras.

Nota: La sangría para la segunda línea (SecondLine) se consigue con el carácter de escape de tabulación, no con espacios.
--------
¡Al infinito, y más allá!
--------
const myStr = "FirstLine\n\t\\SecondLine\nThirdLine";
-------
Concatena cadenas con el operador "más"
En JavaScript, cuando el operador + se utiliza con un valor de cadena (String), se le llama operador de concatenación. Puedes construir una nueva cadena a partir de otras cadenas concatenándolas juntas.

Ejemplo

'My name is Alan,' + ' I concatenate.'
Nota: Ten cuidado con los espacios. La concatenación no añade espacios entre las cadenas concatenadas, así que tendrás que añadirlos por tu cuenta.

Ejemplo:

const ourStr = "I come first. " + "I come second.";
La cadena I come first. I come second. se mostrará en la consola.

Construye myStr a partir de las cadenas This is the start. y This is the end. utilizando el operador +. Asegúrate de incluir un espacio entre las dos cadenas.
------
¡Eres una estrella fugaz!
---------
Concatena cadenas con el operador "más igual"
También podemos utilizar el operador += para concatenar una cadena al final de una variable de cadena existente. Esto puede ser muy útil para romper una cadena larga en varias líneas.

Nota: Ten cuidado con los espacios. La concatenación no añade espacios entre las cadenas concatenadas, así que tendrás que añadirlos por tu cuenta.

Ejemplo:

let ourStr = "I come first. ";
ourStr += "I come second.";
ourStr ahora tiene un valor de la cadena I come first. I come second..

Construye myStr en varias líneas concatenando estas dos cadenas: This is the first sentence. y This is the second sentence. usando el operador +=. Utiliza el operador += similar a como se muestra en el ejemplo y asegúrate de incluir un espacio entre las dos cadenas. Comienza asignando la primera cadena a myStr, luego añade la segunda cadena.
--------
No hay plan B para la pasión!
------
Construye cadenas con variables
A veces necesitarás construir una cadena. Al usar el operador de concatenación (+), puedes insertar una o más variables en una cadena que estés construyendo.

Ejemplo:

const ourName = "freeCodeCamp";
const ourStr = "Hello, our name is " + ourName + ", how are you?";
ourStr tendrá como valor la cadena Hello, our name is freeCodeCamp, how are you?.

Establece myName en una cadena igual a tu nombre y construye myStr con myName entre las cadenas My name is y and I am well!
--------
Un bucle para gobernarlos a todos.
-------
Agrega variables a cadenas
Al igual que podemos crear una cadena sobre múltiples líneas a partir de las cadenas literales, también podemos añadir variables a una cadena usando el operador "más igual" (+=).

Ejemplo:

const anAdjective = "awesome!";
let ourStr = "freeCodeCamp is ";
ourStr += anAdjective;
ourStr tendrá el valor de freeCodeCamp is awesome!.

Establece someAdjective a una cadena de al menos 3 caracteres y añádelo a myStr usando el operador +=.
---------
¡Hasta lo más alto!
------
Encuentra la longitud de una cadena
Puedes encontrar la longitud de un valor de cadena (String) escribiendo .length después de la variable de cadena o literal de cadena.

console.log("Alan Peter".length);
El valor 10 se mostrará en la consola. Toma nota que el carácter espacial entre "Alan" y "Peter" también se cuenta.

Por ejemplo, si creamos una variable const firstName = "Ada", podríamos averiguar la longitud de la cadena Ada usando la propiedad firstName.length.

Utilice la propiedad .length para establecer lastNameLength al número de caracteres en lastName
---------
¡La tribuna se enloquece!
--------
Utiliza la notación de corchetes para encontrar el primer carácter en una cadena
La notación de corchetes es una forma de obtener un carácter en un índice (index) específico dentro de una cadena.

La mayoría de lenguajes de programación modernos, como JavaScript, no empiezan a contar desde 1 como lo hacen los humanos. Empiezan desde 0. Esto se conoce como indexación basada en cero.
==
Por ejemplo, el carácter en el índice 0 de la palabra Charles es C. Así que si declaramos const firstName = "Charles", puedes obtener el valor de la primera letra de la cadena usando firstName[0].

Ejemplo:

const firstName = "Charles";
const firstLetter = firstName[0];
firstLetter tendrá una cadena con valor C.

Utiliza notación de corchetes para encontrar el primer carácter en la variable lastName y asígnalo a firstLetterOfLastName.

Sugerencia: Intenta mirar el ejemplo de arriba si te quedas atascado.
-----------
Programa mucho y prospera
-----------
Comprende la inmutabilidad de las cadenas
En JavaScript, los valores de cadena (String) son inmutables, lo que significa que no pueden ser alterados una vez creados.

Por ejemplo, el siguiente código:

let myStr = "Bob";
myStr[0] = "J";
no puede cambiar el valor de myStr a Job, porque el contenido de myStr no puede ser alterado. Ten en cuenta que esto no significa que myStr no puede cambiarse, solo que los caracteres individuales de una cadena literal no pueden ser cambiados. La única forma de cambiar myStr sería asignarla con una nueva cadena, como esta:

let myStr = "Bob";
myStr = "Job";
Corrige la asignación de myStr para que contenga el valor de cadena Hello World usando el método mostrado en el ejemplo anterior.
---------
¡Eres imparable!
--------
Utiliza la notación de corchetes para encontrar el enésimo carácter en una cadena
También puedes usar notación de corchetes para obtener el carácter en otras posiciones dentro de una cadena.

Recuerda que las computadoras empiezan a contar desde 0, así que el primer carácter es en realidad el carácter cero.

Ejemplo:

const firstName = "Ada";
const secondLetterOfFirstName = firstName[1];
secondLetterOfFirstName tendrá una cadena con valor d.

Intentemos establecer thirdLetterOfLastName (tercera letra del apellido) para que sea igual a la tercera letra de la variable lastName usando notación de corchetes.

Sugerencia: Intenta mirar el ejemplo de arriba si te quedas atascado.
------------
¡Récord de juego!
------------
Utiliza la notación de corchetes para encontrar el último carácter en una cadena
Con el fin de obtener la última letra de una cadena, puedes restar uno a la longitud del texto.

Por ejemplo, sí const firstName = "Ada", puedes obtener el valor de la última letra de la cadena usando firstName[firstName.length - 1].

Ejemplo:

const firstName = "Ada";
const lastLetter = firstName[firstName.length - 1];
lastLetter tendrá una cadena con valor a.

Usa notación de corchetes para encontrar el último carácter en la variable lastName.

Sugerencia: Intenta mirar el ejemplo de arriba si te quedas atascado.
------------
¡Fuera de serie!
----------
Utiliza la notación de corchetes para encontrar el carácter enésimo final en una cadena
Puedes usar el mismo principio que acabamos de usar para recuperar el último carácter de una cadena para recuperar el carácter enésimo final.

Por ejemplo, puedes obtener el valor de la antepenúltima letra de la cadena const firstName = "Augusta" usando firstName[firstName.length - 3]

Ejemplo:

const firstName = "Augusta";
const thirdToLastLetter = firstName[firstName.length - 3];
thirdToLastLetter tendrá una cadena con valor s.

Usa notación de corchetes para encontrar el penúltimo carácter en la cadena lastName.

Sugerencia: Intenta mirar el ejemplo de arriba si te quedas atascado.
------
¡Otra más!
--------
Palabra en blanco
Ahora vamos a usar nuestro conocimiento sobre cadenas para construir un juego de palabras estilo "Mad Libs" que llamaremos "Palabras en blanco". Crearás una frase (opcionalmente humorística) del estilo: Rellena los espacios vacíos.

En un juego de "Mad Libs", se te proporcionan oraciones con algunas palabras faltantes, como sustantivos, verbos, adjetivos y adverbios. Luego, rellenas las piezas que faltan con palabras de tu elección de una manera que la frase completa tenga sentido.

Considera esta oración: It was really ____, and we ____ ourselves ____. Esta oración tiene tres piezas faltantes: un adjetivo, un verbo y un adverbio, y podemos añadir palabras de nuestra elección para completarla. A continuación, podemos asignar la oración completa a una variable de la siguiente manera:

const sentence = "It was really " + "hot" + ", and we " + "laughed" + " ourselves " + "silly" + ".";
En este desafío, te proporcionamos un sustantivo, un verbo, un adjetivo y un adverbio. Necesita formar una oración completa usando palabras de tu elección, junto con las palabras que te proporcionamos.

Necesitarás usar el operador de concatenación de cadenas + para construir una nueva cadena, usando las variables proporcionadas: myNoun, myAdjective, myVerb, y myAdverb. Luego asignarás la cadena formada a la variable wordBlanks. No debes cambiar las palabras asignadas a las variables.

También tendrás que tener en cuenta los espacios en tu cadena, para que la frase final tenga espacios entre todas las palabras. El resultado debe ser una oración completa.
---------
¡Con calma y a codificar!
--------
Almacena múltiples valores en una variable utilizando los arreglos de JavaScript
Con las variables de arreglos (array) de JavaScript, podemos almacenar varios datos en un solo lugar.

Inicias una declaración de arreglo con un corchete de apertura, lo terminas con un corchete de cierre, y pones una coma entre cada entrada, de esta forma:

const sandwich = ["peanut butter", "jelly", "bread"];
Modifica el nuevo arreglo myArray para que contenga tanto una cadena como un número (en ese orden).
------------
¡Hasta lo más alto!
----------
Anida un arreglo dentro de otro arreglo
También puedes anidar arreglos dentro de otros arreglos, como a continuación:

const teams = [["Bulls", 23], ["White Sox", 45]];
Esto también es conocido como arreglo multidimensional.

Crea un arreglo anidado llamado myArray.
---------
¡Ovación de pie!
--------
Accede a los datos de un arreglo con índices
Podemos acceder a los datos dentro de un arreglo usando índices.

Los índices de los arreglos se escriben en la misma notación de corchetes que usan las cadenas de texto, con la excepción que en vez de especificar un carácter, se especifica una entrada en el arreglo. Así como las cadenas de texto, los arreglos usan indexación empezando desde cero, en donde el primer elemento de un arreglo tiene como índice 0.


Ejemplo

const array = [50, 60, 70];
console.log(array[0]);
const data = array[1];
console.log(array[0]) imprime 50, y data tiene el valor 60.

Crea una variable llamada myData y establécela para que sea igual al primer valor de myArray usando notación de corchetes.
----------
¡Haces ver esto fácil!
----------
Modifica los datos de un arreglo con índices
A diferencia de las cadenas, las entradas de los arreglos son mutables y pueden cambiarse libremente, incluso si el arreglo fue declarado con const.

Ejemplo

const ourArray = [50, 40, 30];
ourArray[0] = 15;
ourArray ahora tiene el valor [15, 40, 30].

Nota: No debe haber espacios entre el nombre del arreglo y los corchetes, como array [0]. Aunque JavaScript pueda procesar esto correctamente, puedes confundir a otros programadores al leer tu código.

Modifica los datos almacenados en el índice 0 de myArray a un valor de 45.
--------
¡Incluso Grumpy Cat lo aprueba!
--------
Accede a arreglos multidimensionales con índices
Se puede pensar que un arreglo multidimensional es como un arreglo de arreglos. Cuando usas corchetes para acceder a tu arreglo, el primer par de corchetes se refiere a las entradas en el arreglo externo (el primer nivel) y cada par adicional de corchetes se refiere al siguiente nivel de entradas.

Ejemplo

const arr = [
  [1, 2, 3],
  [4, 5, 6],
  [7, 8, 9],
  [[10, 11, 12], 13, 14]
];

arr[3];
arr[3][0];
arr[3][0][1];
arr[3] es [[10, 11, 12], 13, 14], arr[3][0] es [10, 11, 12] y arr[3][0][1] es 11.

Nota: No debe haber ningún espacio entre el nombre del arreglo y los corchetes, ni array [0][0] o array [0] [0] están permitidos. Aunque JavaScript pueda procesar esto correctamente, puedes confundir a otros programadores al leer tu código.

Usa la notación de corchetes para seleccionar un elemento de myArray de tal manera que myData sea igual a 8.
-----------
¡Estallido supersónico!
---------
Manipula arreglos con push()
Una forma fácil de añadir datos al final de un arreglo es a través de la función push().

.push() toma uno o más parámetros y los "empuja" al final del arreglo.

Ejemplos:

const arr1 = [1, 2, 3];
arr1.push(4);

const arr2 = ["Stimpson", "J", "cat"];
arr2.push(["happy", "joy"]);
arr1 ahora tiene el valor [1, 2, 3, 4] y arr2 tiene el valor ["Stimpson", "J", "cat", ["happy", "joy"]].

Empuja ["dog", 3] al final de la variable myArray.
----------
¡Estás en llamas!
----------
¡Al batimóvil!
------------
Una forma fácil de añadir datos al final de un arreglo es a través de la función push().

.push() toma uno o más parámetros y los "empuja" al final del arreglo.

Ejemplos:

const arr1 = [1, 2, 3];
arr1.push(4);

const arr2 = ["Stimpson", "J", "cat"];
arr2.push(["happy", "joy"]);
arr1 ahora tiene el valor [1, 2, 3, 4] y arr2 tiene el valor ["Stimpson", "J", "cat", ["happy", "joy"]].

Empuja ["dog", 3] al final de la variable myArray.
-----------------
Otra manera de cambiar los datos en un arreglo es con la función .pop().

.pop() se utiliza para sacar un valor del final de un arreglo. Podemos almacenar este valor sacado asignándolo a una variable. En otras palabras, .pop() elimina el último elemento de un arreglo y devuelve ese elemento.

Cualquier tipo de entrada puede ser sacada de un arreglo: números, cadenas, incluso arreglos anidados.

const threeArr = [1, 4, 6];
const oneDown = threeArr.pop();
console.log(oneDown);
console.log(threeArr);
El primer console.log mostrará el valor 6 y el segundo mostrará el valor [1, 4].

Utiliza la función .pop() para eliminar el último elemento de myArray, y asigna el valor sacado a un variable nuevo removedFromMyArray.
------------------
ipulate Arrays With pop() 58
Problem Explanation
Remove the last element in the array and assign it to removedFromMyArray.

Hints
Hint 1
Call .pop() on the array, and assign it to removedFromMyArray.

Solutions
Solution 1 (Click to Show/Hide)
// Setup
var myArray = [["John", 23], ["cat", 2]];

// Only change code below this line
var removedFromMyArray = myArray.pop();
---------------
¡La tribuna se enloquece!
----------
Manipula arreglos con shift()
pop() siempre elimina el último elemento de un arreglo. ¿Qué tal si quieres eliminar el primero?

Ahí es donde entra .shift(). Funciona igual que .pop(), excepto que elimina el primer elemento en lugar del último.

Ejemplo:

const ourArray = ["Stimpson", "J", ["cat"]];
const removedFromOurArray = ourArray.shift();
removedFromOurArray tendrá una cadena con valor Stimpson y ourArray tendrá ["J", ["cat"]].

Utiliza la función .shift() para eliminar el primer elemento de myArray, y asigna el valor "desplazado" a un variable nuevo removedFromMyArray.
-------
¡Tienes el toque!
-------
Manipula arreglos con unshift()
No solo puedes desplazar (shift) elementos del comienzo de un arreglo, también puedes des-desplazar (unshift) elementos al comienzo de un arreglo. Por ejemplo añadir elementos delante del arreglo.

.unshift() funciona exactamente como .push(), pero en lugar de añadir el elemento al final del arreglo, unshift() añade el elemento al principio del arreglo.

Ejemplo:

const ourArray = ["Stimpson", "J", "cat"];
ourArray.shift();
ourArray.unshift("Happy");
Después del shift, ourArray tendrá el valor ["J", "cat"]. Después del unshift, ourArray tendrá el valor ["Happy", "J", "cat"].

Agrega ["Paul", 35] al principio de la variable myArray usando unshift().
---------
¡Haces ver esto fácil!
---------
Crea una lista de compras en la variable myList. La lista debe ser un arreglo multidimensional que contenga varios sub-arreglos.

El primer elemento de cada sub-arreglo debe contener una cadena con el nombre del artículo. El segundo elemento debe ser un número que represente la cantidad, por ejemplo.

["Chocolate Bar", 15]
Debe haber al menos 5 sub-arreglos en la lista.

--------------
Shopping List 144
Hints
Hint 1
A multi-dimensional array would have the following outline [[]].
Escribe JavaScript reutilizable utilizando funciones

En JavaScript, podemos dividir nuestro código en partes reutilizables llamadas funciones.



Este es un ejemplo de una función:



function functionName() {

  console.log("Hello World");

}

Puedes llamar o invocar esta función usando su nombre seguido por paréntesis, así: functionName(); Cada vez que se llame la función se imprimirá el mensaje Hello World en la consola de desarrollo. Todo el código entre las llaves se ejecutará cada vez que se llame la f
Hint 2
Each sub-array should be separated by , as would any item in an array.

Hint 3
Don’t forget the ; at the end of your declaration.

Solutions
Solution 1 (Click to Show/Hide)
var myList = [
  ["Canned Beans", 3],
  ["Milk Galon", 1],
  ["Cereal", 2],
  ["Toilet Paper", 12],
  ["Sack of Rice", 1]
];
Code Explanation
A multi-dimensional array is created.
The array consists five arrays inside, each composed of a string and an integer, in the same order.
Relevant Links
Challenge:Nest one Array within Another Array 255
-------------
¡Prístina Luna, dame el poder!
-------------
Escribe JavaScript reutilizable utilizando funciones
En JavaScript, podemos dividir nuestro código en partes reutilizables llamadas funciones.

Este es un ejemplo de una función:

function functionName() {
  console.log("Hello World");
}
Puedes llamar o invocar esta función usando su nombre seguido por paréntesis, así: functionName(); Cada vez que se llame la función se imprimirá el mensaje Hello World en la consola de desarrollo. Todo el código entre las llaves se ejecutará cada vez que se llame la función.

Crea una función llamada reusableFunction que imprima la cadena Hi World en la consola de desarrollo.
Llama a la función.
---------
freeCodeCamp Challenge Guide: Write Reusable JavaScript with Functions
Guide

camperbot
Great contributor

6
May '21
Write Reusable JavaScript with Functions 123
Problem Explanation
Functions allow you to reuse code over and over. Our task is to make a simple reusableFunction() that prints out “Hi World” to the console (which you can reach with Ctrl + Shift + I).

You start off by using the function keyword, and then typing the function name (which follows Camel Case formatting). Then, type the (), and create the {} brackets. Like so:

function reusableFunction() {}
Now, your function is ready to be typed in. Use the console.log() to print a message in the console.

Solutions
Solution 1 (Click to Show/Hide)
// Define the function
function reusableFunction() {
  console.log("Hi World");
}

// Call the function
reusableFunction();
-----------
¡Haz que llueva!
-------
Pasa valores a las funciones utilizando argumentos
Los parámetros son variables que actúan como marcadores de posición para los valores que deben ser introducidos en una función cuando se llama. Cuando se define una función, se define típicamente junto con uno o más parámetros. Los valores reales que son introducidos (o "pasados") a una función cuando se llama son conocidos como argumentos.

Esta es una función con dos parámetros, param1 y param2:

function testFun(param1, param2) {
  console.log(param1, param2);
}
Entonces podemos llamar a testFun así: testFun("Hello", "World");. Hemos pasado dos argumentos de cadena, Hello y World. Dentro de la función, param1 será igual a la cadena Hello y param2 será igual a la cadena World. Ten en cuenta que podrías llamar a testFun otra vez con diferentes argumentos y los parámetros tomarían el valor de los nuevos argumentos.

Crea una función llamada functionWithArgs que acepte dos argumentos y muestre la suma de ellos en la consola de desarrollador.
Llama a la función con dos números como argumentos.
------------
Passing Values to Functions with Arguments 802
Problem Explanation
Our task is to create a function that has parameters. These are inputs that determine the function’s output. You place paramaters inside the (), like so:

function functionWithArgs(one, two) {
  console.log(one + two);
}
We now have to add code inside the brackets. Our task is to add one and two, and print the sum to the console.

functionWithArgs(7, 3);
//This will console log 10.
---------------
function functionWithArgs(param1,param2){
  console.log(param1+param2);
}
functionWithArgs(1,2);
functionWithArgs(7,9);
------
¡Incluso Grumpy Cat lo aprueba!
-------
Devuelve un valor de una función utilizando "Return"
Podemos pasar valores a una función con argumentos. Puedes utilizar una declaración de devolución (return) para enviar un valor fuera de una función.

Ejemplo

function plusThree(num) {
  return num + 3;
}

const answer = plusThree(5);
answer tiene el valor 8.

plusThree toma un argumento para num y devuelve un valor igual a num + 3.

Crea una función timesFive que acepte un argumento, lo multiplique por 5y devuelva el nuevo valor.
----------
Return a Value from a Function with Return 70
Problem Explanation
Using return, you can make functions output data.

Solutions
Solution 1 (Click to Show/Hide)
function timesFive(num) {
  return num * 5;
}
----------
¡No contaban con tu astucia!
--------
Ámbito global y funciones
En JavaScript, el ámbito se refiere a la visibilidad de las variables. Las variables definidas fuera de un bloque de función tienen un ámbito Global. Esto significa que pueden ser observadas desde cualquier lugar en tu código JavaScript.

Las variables que se declaran sin las palabras clave let o const se crean automáticamente en el ámbito global. Esto puede crear consecuencias no intencionadas en cualquier lugar de tu código o al volver a ejecutar una función. Siempre debes declarar tus variables con let o const.

Usando let o const, declara una variable global llamada myGlobal fuera de cualquier función. Inicialízala con un valor de 10.

Dentro de la función fun1, asigna 5 a oopsGlobal sin usar las palabras clave let o const.
-----------
freeCodeCamp Challenge Guide: Global Scope and Functions
Guide

camperbot
Great contributor

5
Oct '19
Global Scope and Functions 75
Hints
Hint 1
The scope of a variable is its visibility; where in the code is the function available? Here is a list of the different scopes a variable can have.

Global scope: The variable is available throughout the code
Local scope: Available in only a certain area (like only within function)
Block scope: Available within an even more certain area (like an if-statement)
Your task is to understand how adding var (and not adding) before a variable name, can change the variable’s scope.

When you add var before the variable name, its scope is determined by where it is placed. Like so:

var num1 = 18; // Global scope
function fun() {
  var num2 = 20; // Local (Function) Scope
  if (true) {
    var num3 = 22; // Block Scope (within an if-statement)
  }
}
When you don’t, this is the result:

num1 = 18; // Global scope
function fun() {
  num2 = 20; // Global Scope
  if (true) {
    num3 = 22; // Global Scope
  }
}
Solutions
Solution 1 (Click to Show/Hide)
// Declare your variable here
var myGlobal = 10;

function fun1() {
  oopsGlobal = 5;
}

// Only change code above this line
function fun2() {
  var output = "";
  if (typeof myGlobal != "undefined") {
    output += "myGlobal: " + myGlobal;
  }
  if (typeof oopsGlobal != "undefined") {
    output += " oopsGlobal: " + oopsGlobal;
  }
  console.log(output);
}
------------
Ámbito local y funciones
Las variables que se declaran dentro de una función, así como los parámetros de la función tienen un ámbito local. Esto significa que sólo son visibles dentro de esa función.

Esta es una función myTest con una variable local llamada loc.

function myTest() {
  const loc = "foo";
  console.log(loc);
}

myTest();
console.log(loc);
La llamada a la función myTest() mostrará la cadena foo en la consola. La línea console.log(loc) (fuera de la función myTest) lanzará un error, ya que loc no está definido fuera de la función.

El editor tiene dos console.logs para ayudarte a ver lo que está sucediendo. Revisa la consola a medida que programas para ver cómo cambia. Declara una variable local myVar dentro de myLocalScope y ejecuta las pruebas.

Nota: La consola todavía mostrará el error ReferenceError: myVar is not defined, pero esto no causará que las pruebas fallen.
------------
Problem Explanation
Local scope means that the variable is available within a certain area. In the case of this exercise, myVar is only available within the function, and not anywhere outside.

Solutions
Solution 1 (Click to Show/Hide)
function myLocalScope() {

  // Only change code below this line
  var myVar;
  console.log('inside myLocalScope', myVar);
}
myLocalScope();

// Run and check the console
// myVar is not defined outside of myLocalScope
console.log('outside myLocalScope', myVar);
Code Explanation
The variable only exists in the function. Outside the function, it is non-existent.
------------------
¡Ríe y el mundo reirá contigo!
-------------
Ámbito global vs. local en funciones
Es posible tener variables locales y globales con el mismo nombre. Cuando haces esto, la variable local tiene precedencia sobre la variable global.

En este ejemplo:

const someVar = "Hat";

function myFun() {
  const someVar = "Head";
  return someVar;
}
La función myFun devolverá la cadena Head porque está presente la versión local de la variable.

Añade una variable local a la función myOutfit para sobrescribir el valor de outerWear con la cadena sweater.
-----------
¡Lo hiciste!
--------
Comprendiendo el valor indefinido devuelto por una función
Una función puede incluir la declaración de devolución (return) pero no tiene por qué hacerlo. En el caso de que la función no tenga una declaración de devolución (return), cuando la llames, la función procesa el código interno, pero el valor devuelto es undefined (indefinido).

Ejemplo

let sum = 0;

function addSum(num) {
  sum = sum + num;
}

addSum(3);
addSum es una función sin una declaración de devolución (return). La función cambiará la variable global sum pero el valor devuelto de la función es undefined.

Crea una función addFive sin ningún argumento. Esta función suma 5 a la variable sum, pero su valor devuelto es undefined.
-------------Understanding Undefined Value returned from a Function 603
Hints
Hint 1
A function with no return statement, has an output of undefined. So, if you try to equal a varaible to the output of a function with no return statement, that variable will equal undefined.

Go ahead and define addFive() like so…

function addFive() {
  sum += 5;
}
As you can see, sum is added by 5 with no issues, but since there is no return statement, there is an undefined output.

var result = addFive(); // This is undefined
-------------
¡Súper combo!
-------
/ Configuración
let sum = 0;

function addThree() {
  sum = sum + 3;
}

// Cambia solo el código debajo de esta línea
function addFive(){
  sum+=5;
}
// Cambia solo el código encima de esta línea

addThree();
addFive();
-----------
Algoritmos de JavaScript y Estructuras de Datos
JavaScript básico
Comprendiendo el valor indefinido devuelto por una función
Una función puede incluir la declaración de devolución (return) pero no tiene por qué hacerlo. En el caso de que la función no tenga una declaración de devolución (return), cuando la llames, la función procesa el código interno, pero el valor devuelto es undefined (indefinido).

Ejemplo

let sum = 0;

function addSum(num) {
  sum = sum + num;
}

addSum(3);
addSum es una función sin una declaración de devolución (return). La función cambiará la variable global sum pero el valor devuelto de la función es undefined.

Crea una función addFive sin ningún argumento. Esta función suma 5 a la variable sum, pero su valor devuelto es undefined.
------------
¡A conquistar el mundo!
-----------
Asignación con un valor devuelto
Si recuerdas de nuestra discusión sobre almacenar valores con el operador de asignación, todo a la derecha del signo de igualdad se resuelve antes de asignar el valor. Esto significa que podemos tomar el valor devuelto de una función y asignarlo a una variable.

Supongamos que hemos predefinido una función sum que suma dos números juntos, entonces:

ourSum = sum(5, 12);
llamará a la función sum, que devuelve un valor de 17 y lo asigna a la variable ourSum.

Llama la función processArg con un argumento de 7 y asigna su valor de retorno a la variable processed.

-------------
Hints
Hint 1
Functions act as placeholders for the data they output. Basically, you can assign the output of a function to a variable, just like any normal data.

Solutions
Solution 1 (Click to Show/Hide)
processed = processArg(7); // Equal to 2
--------
¡Súper combo!
---------
Permanece en línea
En Informática una cola (queue) es una estructura de datos abstracta donde los elementos se mantienen en orden. Los nuevos elementos se pueden añadir en la parte posterior de la cola y los elementos antiguos se retiran de la parte delantera de la cola.

Escribe una función nextInLine que tome un arreglo (arr) y un número (item) como argumentos.

Agrega el número al final del arreglo, luego elimina el primer elemento del arreglo.

La función nextInLine debe entonces devolver el elemento que fue removido.
----------
Stand in Line 517
Hints
Hint 1
The push() method adds an item to the end of an array.

Hint 2
The shift() method removes the first element of an array. It also returns the element removed.

Hint 3
The function nextInLine uses arr and item. Those are what the tests will use to pass the array elements they will test with. It allows the function to be reusable. Do not hardcode any of the tests inside the function.

Solutions
Solution 1 (Click to Show/Hide)
function nextInLine(arr, item) {
  // Only change code below this line
  arr.push(item);
  const removed = arr.shift();
  return removed;
  // Only change code above this line
}
Code Explanation
Push item at the end of arr.
Call the shift() method on arr to get the first item and store it in removed.
Return removed.
Example Run

Test nextInLine([2,1]); runs.
The nextInLine function is called. arr becomes [2]. item becomes 1.
arr.push(item); Pushes 1 to [2]. So arr is now [2,1].
const removed = arr.shift(); removes the first element. So arr is now [1]. 2 has been removed and is stored in removed.
return removed; 2 is returned.
Note: You don’t actually need the variable removed. The element removed can be returned directly using return arr.shift();.
----------------
¡Una para los Récords Guinness!
-----------------
Comprende los valores booleanos
Otro tipo de datos es el Booleano. Los booleanos solo pueden ser uno de dos valores: true (verdadero) o false (falso). Básicamente son pequeños interruptores de encendido, donde true es encendido y false es apagado. Estos dos estados se excluyen mutuamente.

Nota Los valores del tipo booleano nunca se escriben con comillas. Las cadenas "true" y "false" no son booleanos y no tienen ningún significado especial en JavaScript.

Modifica la función welcomeToBooleans para que devuelva true en lugar de false cuando se haga clic en el botón de ejecución.
----------------------
¡Prístina Luna, dame el poder!
----------
Usa lógica condicional con las sentencias "If"
Las sentencias if son utilizadas para tomar decisiones en el código. La palabra clave if le dice a JavaScript que ejecute el código entre llaves bajo ciertas condiciones, definidas en los paréntesis. Estas condiciones son conocidas como condiciones booleanas (Boolean) y sólo pueden ser true o false.

Cuando la condición se evalúa como true, el programa ejecuta el comando dentro de las llaves. Cuando la condición booleana se evalúa como false, la sentencia dentro de las llaves no se ejecutará.

Pseudocódigo

si (la condición es verdadera) {
  la sentencia es ejecutada
}
Ejemplo

function test (myCondition) {
  if (myCondition) {
    return "It was true";
  }
  return "It was false";
}

test(true);
test(false);
test(true) devuelve la cadena It was true y test(false) devuelve la cadena It was false.

Cuando test es llamada con un valor de true, la sentencia if evalúa myCondition (mi condición) para ver si es true o no. Puesto que es true, la función devuelve It was true. Cuando llamamos a test con un valor de false, myCondition no es true, la sentencia dentro de las llaves no se ejecuta y la función devuelve It was false.

Crea una sentencia if dentro de la función que devuelva Yes, that was true si el parámetro wasThatTrue es true y devuelva No, that was false en caso contrario.
--------------
¡Con el volumen a 11!
------------------
Comparación con el operador de igualdad
Hay muchos operadores de comparación en JavaScript. Todos estos operadores devuelven un valor booleano true o false.

El operador más básico es el de igualdad ==. El operador de igualdad compara dos valores y devuelve true si son equivalentes o false si no lo son. Ten en cuenta que una igualdad es diferente a una asignación (=), la cual asigna el valor a la derecha del operador a la variable de la izquierda.

function equalityTest(myVal) {
  if (myVal == 10) {
    return "Equal";
  }
  return "Not Equal";
}
Si myVal es igual a 10, el operador de igualdad devuelve true, así que el código dentro de los corchetes se ejecutará y la función devolverá Equal. De lo contrario, la función devolverá Not Equal. Para que JavaScript compare dos tipos de datos diferentes (por ejemplo, numbers y strings), tiene que convertir un tipo a otro. Esto se conoce como coerción de Tipo. Sin embargo, una vez lo hace, puede comparar términos como se ve a continuación:

1   ==  1  // true
1   ==  2  // false
1   == '1' // true
"3" ==  3  // true
Agrega el operador de igualdad a la línea indicada para que la función devuelva la cadena Equal cuando val sea equivalente a 12.
---------
¡Es el momento perfecto para ser histérico!
---------
Comparación con el operador de estricta igualdad
La estricta igualdad (===) es la contraparte del operador de igualdad (==). Sin embargo, a diferencia del operador de igualdad, el cual intenta convertir ambos valores comparados a un tipo común, el operador de estricta igualdad no realiza una conversión de tipo.

Si los valores que se comparan tienen diferentes tipos, se consideran desiguales, y el operador de estricta igualdad devolverá falso.

Ejemplos

3 ===  3  // true
3 === '3' // false
En el segundo ejemplo, 3 es de tipo Number (número) y '3' es de tipo String (cadena).

Usa el operador de estricta igualdad en la sentencia if para que la función devuelva la cadena Equal cuando val sea estrictamente igual a 7.
--------------------
¡Eres un mago, Harry!
--------------------
Practica comparando diferentes valores
En los dos últimos desafíos, aprendimos sobre el operador de igualdad (==) y el operador de estricta igualdad (===). Vamos a hacer una rápida revisión y práctica utilizando estos operadores un poco más.

Si los valores que se comparan no son del mismo tipo, el operador de igualdad realizará una conversión de tipo y luego evaluará los valores. Sin embargo, el operador de estricta igualdad comparará tanto el tipo de datos como el valor tal como es, sin convertir un tipo a otro.

Ejemplos

3 == '3' devuelve true porque JavaScript realiza la conversión de tipo de cadena a número. 3 === '3' devuelve false porque los tipos son diferentes y la conversión de tipo no se realiza.

Nota: En JavaScript, puedes determinar el tipo de una variable o un valor con el operador typeof, de la siguiente manera:

typeof 3
typeof '3'
typeof 3 devuelve la cadena number y typeof '3' devuelve la cadena string.

La función compareEquality en el editor compara dos valores usando el operador de igualdad. Modifica la función para que devuelva la cadena Equal sólo cuando los valores son estrictamente iguales.
------------
¡Con el volumen a 11!
---------
Comparación con el operador de desigualdad
El operador de desigualdad (!=) es lo opuesto al operador de igualdad. Esto quiere decir que no es igual, y devuelve false cuando la comparación de igualdad devuelva true y vice versa. Al igual que el operador de igualdad, el operador de desigualdad convertirá los tipos de datos mientras los compara.

Ejemplos

1 !=  2    // true
1 != "1"   // false
1 != '1'   // false
1 != true  // false
0 != false // false
Agrega el operador de desigualdad != en la sentencia if para que la función devuelva la cadena Not Equal cuando val no sea equivalente a 99.
------------
¡Eres imparable!
-------------
Comparación con el operador de estricta desigualdad
El operador de estricta desigualdad !== es el opuesto lógico del operador de estricta igualdad. Esto significa "Estrictamente Desigual", y devuelve false cuando la comparación de estricta igualdad devolvería true y vice versa. El operador de estricta desigualdad no convertirá los tipos de datos.

Ejemplos

3 !==  3  // false
3 !== '3' // true
4 !==  3  // true
Agrega el operador de estricta desigualdad a la sentencia if para que la función devuelva la cadena Not Equal cuando val no sea estrictamente igual a 17
--------------
Está vivo. ¡Está vivo!
----------------
Comparación con el operador "mayor que"
El operador mayor que (>) compara los valores de dos números. Si el número a la izquierda es mayor que el número a la derecha, devuelve true. De lo contrario, devuelve false.

Al igual que el operador de igualdad, el operador mayor que convertirá los tipos de datos de valores mientras los compara.

Ejemplos

5   >  3  // true
7   > '3' // true
2   >  3  // false
'1' >  9  // false
Agrega el operador mayor que a las líneas indicadas para que las declaraciones de devolución tengan sentido.
----------
6
Oct '19
Comparison with the Greater Than Operator 32
Problem Explanation
· Add the greater than operator to the indicated lines so that the return statements make sense.

Hints
Hint 1
The greater than operator (>) compares both operands using type coercion (converting data types if necessary) and returns true if the first one is greater than the second one.

Solutions
Solution 1 (Click to Show/Hide)
function testGreaterThan(val) {
  if (val > 100) {
    // Change this line
    return "Over 100";
  }

  if (val > 10) {
    // Change this line
    return "Over 10";
  }

  return "10 or under";
}

// Change this value to test
testGreaterThan(10);
Code Explanation
The function first evaluates if the condition (val > 100) evaluates to true converting val to a number if necessary. If it does, it returns the statement between the curly braces (“Over 100”). If it doesn’t, it checks if the next condition is true (returning “Over 10”). Otherwise the function will return “10 or under”.

Relevant Links
“Greater than operator (>)” - MDN JavaScript reference 57
----------
¡La cuchara no existe, Neo!
----------
Comparación con el operador "mayor o igual que"
El operador mayor o igual que (>=) compara el valor de dos números. Si el número de la izquierda es mayor o igual que el número de la derecha, devuelve true. De lo contrario, devuelve false.

Al igual que el operador de igualdad, el operador mayor o igual que convertirá los tipos de datos mientras los compara.

Ejemplos

6   >=  6  // true
7   >= '3' // true
2   >=  3  // false
'7' >=  9  // false
Agrega el operador mayor o igual que a las líneas indicadas para que el valor devuelto tenga sentido.
-------------
¡Esto es pan comido!
-----------
Comparación con el operador "menor que"
El operador menor que (<) compara los valores de dos números. Si el número a la izquierda es menor que el número a la derecha, devuelve true. De lo contrario, devuelve false. Al igual que el operador de igualdad, el operador menor que convertirá los tipos de datos mientras los compara.

Ejemplos

2   < 5 // true
'3' < 7 // true
5   < 5 // false
3   < 2 // false
'8' < 4 // false
Agrega el operador menor que a las líneas indicadas para que las declaraciones de devolución tengan sentido.
-------------------
Comparación con el operador "menor que"
El operador menor que (<) compara los valores de dos números. Si el número a la izquierda es menor que el número a la derecha, devuelve true. De lo contrario, devuelve false. Al igual que el operador de igualdad, el operador menor que convertirá los tipos de datos mientras los compara.

Ejemplos

2   < 5 // true
'3' < 7 // true
5   < 5 // false
3   < 2 // false
'8' < 4 // false
Agrega el operador menor que a las líneas indicadas para que las declaraciones de devolución tengan sentido.
--------------
Comparación con el operador "menor que"
El operador menor que (<) compara los valores de dos números. Si el número a la izquierda es menor que el número a la derecha, devuelve true. De lo contrario, devuelve false. Al igual que el operador de igualdad, el operador menor que convertirá los tipos de datos mientras los compara.

Ejemplos

2   < 5 // true
'3' < 7 // true
5   < 5 // false
3   < 2 // false
'8' < 4 // false
Agrega el operador menor que a las líneas indicadas para que las declaraciones de devolución tengan sentido.
-------------
¡Bingo!
------------
Comparación con el operador "menor o igual que"
El operador menor o igual que (<=) compara el valor de dos números. Si el número de la izquierda es menor o igual que el número de la derecha, devuelve true. Si el número a la izquierda es mayor que el número a la derecha, devuelve false. Al igual que el operador de igualdad, el operador menor o igual que convertirá los tipos de datos mientras los compara.

Ejemplos

4   <= 5 // true
'7' <= 7 // true
5   <= 5 // true
3   <= 2 // false
'8' <= 4 // false
Agrega el operador menor o igual que a las líneas indicadas para que el valor devuelto tenga sentido.
-----------------
¡Hasta lo más alto!
----------------
Comparaciones con el operador lógico "and"
A veces tendrás que probar más de una cosa a la vez. El operador lógico and (&&) devuelve true si y solo si los operandos a la izquierda y a la derecha son verdaderos.

El mismo efecto se podría lograr anidando una sentencia if dentro de otra sentencia if:

if (num > 5) {
  if (num < 10) {
    return "Yes";
  }
}
return "No";
solo devolverá Yes si num es mayor que 5 y menor que 10. La misma lógica se puede escribir como:

if (num > 5 && num < 10) {
  return "Yes";
}
return "No";
Reemplaza las dos sentencias if por una sola, usando el operador &&, el cual devolverá la cadena Yes si val es menor o igual a 50 y mayor o igual a 25. De lo contrario, devolverá la cadena No.
-------------
¡Lo tienes!
--------------
Comparaciones con el operador lógico "or"
El operador lógico or (||) devuelve true si cualquiera de los operandos es true. De lo contrario, devuelve false.

El operador lógico or se compone de dos símbolos de barra vertical: (||). Este se puede encontrar normalmente entre las teclas de tabulación y escape.

El patrón de abajo debería parecer familiar desde los puntos de referencia anteriores:

if (num > 10) {
  return "No";
}
if (num < 5) {
  return "No";
}
return "Yes";
devolverá Yes sólo si num está entre 5 y 10 (5 y 10 incluidos). La misma lógica se puede escribir como:

if (num > 10 || num < 5) {
  return "No";
}
return "Yes";
Combina las dos sentencias if en una sola sentencia que devuelva la cadena Outside si val no está entre 10 y 20, inclusivo. De lo contrario, devuelve la cadena Inside.
------------
Eso no fue volar. Eso fue caer con estilo
------------
Introducción a las sentencias "Else"
Cuando la condición en una sentencia if es verdadera, se ejecutará el bloque de código que va a continuación. ¿Qué sucede cuando la condición es falsa? Normalmente no debería ocurrir nada. Con la sentencia else, se puede ejecutar un bloque alternativo de código.

if (num > 10) {
  return "Bigger than 10";
} else {
  return "10 or Less";
}
Combina la sentencia if en una sola sentencia if/else.
--------------
¡Asalta ese castillo!
------------
Introducción a las sentencias "Else If"
Si tienes múltiples condiciones que necesitan ser resueltas, puedes encadenar sentencias if junto con sentencias else if.

if (num > 15) {
  return "Bigger than 15";
} else if (num < 5) {
  return "Smaller than 5";
} else {
  return "Between 5 and 15";
}
Transforma la lógica para utilizar la sentencia else if.
-------------
¡Esto es pan comido!
-----------------
Orden lógico de las sentencias "if else"
El orden es importante en las sentencias if, else if.

La función se ejecuta de arriba a abajo, por lo que habrá que tener cuidado con qué sentencia va primero.

Tomemos como ejemplo estas dos funciones.

Aquí está la primera:

function foo(x) {
  if (x < 1) {
    return "Less than one";
  } else if (x < 2) {
    return "Less than two";
  } else {
    return "Greater than or equal to two";
  }
}
Y la segunda, simplemente cambia el orden de las sentencias:

function bar(x) {
  if (x < 2) {
    return "Less than two";
  } else if (x < 1) {
    return "Less than one";
  } else {
    return "Greater than or equal to two";
  }
}
Mientras que estas dos funciones parecen casi idénticas, si pasamos un número a ambas, obtenemos diferentes salidas.

foo(0)
bar(0)
foo(0) devolverá la cadena Less than one, y bar(0) devolverá la cadena Less than two.

Cambia el orden lógico en la función para que devuelva el resultado correcto en todos los casos.
----------------
Logical Order in If Else Statements 138
Hints
Hint 1
So be careful while using the if, else if and else statements and always remember that these are executed from top to bottom. Keep this in mind placing your statements accordingly so that you get the desired output.

Solutions
Solution 1 (Click to Show/Hide)
function orderMyLogic(val) {
  if(val < 5) {
    return "Less than 5";
  } else if (val < 10) {
    return "Less than 10";
  } else {
    return "Greater than or equal to 10";
  }
}
-----------------------
¡Hasta lo más alto!
--------------
Encadena sentencias if else
Las sentencias if/else pueden ser encadenadas para crear una lógica compleja. Aquí hay pseudocódigo de múltiples declaraciones if / else if encadenadas:

if (condition1) {
  statement1
} else if (condition2) {
  statement2
} else if (condition3) {
  statement3
. . .
} else {
  statementN
}
Escribe sentencias if / else if encadenadas para cumplir con las siguientes condiciones:

num < 5 - devuelve Tiny
num < 10 - devuelve Small
num < 15 - devuelve Medium
num < 20 - devuelve Large
num >= 20 - devuelve Huge
-------------
¡Aprobado con honores!
-----------
Código de golf
En el juego de Golf, cada agujero tiene un par, que significa, el número promedio de strokes que se espera que haga un golfista para hundir la pelota en el agujero para completar el juego. Dependiendo de qué tan por encima o por debajo del par estén tus strokes, hay un nombre diferente.

Tu función recibirá los argumentos par y strokes. Devuelve la cadena correcta según esta tabla que muestra los golpes en orden de prioridad; superior (más alto) a inferior (más bajo):

Strokes (golpes)		Devuelve
1					"Hole-in-one!"
<= par - 2			"Eagle"
par - 1				"Birdie"
par					"Par"
par + 1				"Bogey"
par + 2				"Double Bogey"
>= par + 3			"Go Home!"
par y strokes siempre serán numéricos y positivos. Hemos añadido un arreglo de todos los nombres para tu conveniencia.
--------
freeCodeCamp Challenge Guide: Golf Code
Guide

camperbot
Great contributor

8
Jan 10
Golf Code 240
Hints
Problem Explanation
Change the code below // Only change code below this line and above // Only change code above this line.

Ensure that you’re editing the inside of the golfScore function.

You will have to make the function return exactly the same string as shown shown in the table, depending on the value of the parameters par and strokes that are passed to your function.

Hint 1
+number -number can be used to increase or decrease a parameter in your condition.

Hint 2
You use if / else if chains to return different values in different scenarios.

Hint 3
Control the flow of your function based on the tables order of priority - top (highest) to bottom (lowest) to return matching string values.

Solutions
Solution 1 (Click to Show/Hide)
const names = ["Hole-in-one!", "Eagle", "Birdie", "Par", "Bogey", "Double Bogey", "Go Home!"];

function golfScore(par, strokes) {
  // Only change code below this line
  if (strokes == 1) {
    return names[0];
  } else if (strokes <= par - 2) {
    return names[1];
  } else if (strokes === par - 1) {
    return names[2];
  } else if (strokes === par) {
    return names[3];
  } else if (strokes === par + 1) {
    return names[4];
  } else if (strokes === par + 2) {
    return names[5];
  } else {
    return names[6];
  }
  // Only change code above this line
}

// Change these values to test
golfScore(5, 4);
Code Explanation
Since we already have an array defined in the variable names we can take advantage of it and use it for our return statements using indexes (eg: names[0] is the first one). That way, if you ever need to change a specific result you wouldn’t need to look for it inside the function, it’d be at the beginning, in your array.

Solution 2 (Click to Show/Hide)
(Using Multiple Conditional (Ternary) Operators)

const names = ["Hole-in-one!", "Eagle", "Birdie", "Par", "Bogey", "Double Bogey", "Go Home!"];

function golfScore(par, strokes) {
  return strokes === 1
    ? names[0]
    : strokes <= par - 2
    ? names[1]
    : strokes === par - 1
    ? names[2]
    : strokes === par
    ? names[3]
    : strokes === par + 1
    ? names[4]
    : strokes === par + 2
    ? names[5]
    : names[6];
}
Relevant Links
Golf 479
Challenge: Chaining If Else Statements 397
Challenge: Comparison with the Greater Than Equal To Operator 246
Challenge: Comparison with the Less Than Equal To Operator 144
“Array” - MDN JavaScript reference 62
Use Multiple Conditional (Ternary) Operators 292
Note that using deeply nested ternaries like this is discouraged in professional code.
-----------
¡Excelente!
-----------
Seleccionando entre muchas opciones con declaración switch
Si tienes muchas opciones para elegir, usa una declaración switch. Una sentencia switch prueba un valor y puede tener muchas sentencias case que definen varios valores posibles. Las sentencias se ejecutan desde el primer valor case coincidente hasta que se encuentra un break.

Aquí hay un ejemplo de una declaración switch:

switch (lowercaseLetter) {
  case "a":
    console.log("A");
    break;
  case "b":
    console.log("B");
    break;
}
Los valores en las sentencias case se prueban con igualdad estricta (===). El break le dice a JavaScript que deje de ejecutar declaraciones. Si se omite break, se ejecutara la siguiente sentencia.

Escribe una declaración switch que pruebe val y establezca answer con las siguientes condiciones:
1 - alpha
2 - beta
3 - gamma
4 - delta
-----------
freeCodeCamp Challenge Guide: Selecting from Many Options with Switch Statements
Guide

camperbot
Great contributor

10
Jan 27
Selecting from Many Options with Switch Statements 206
Problem Explanation
A switch statement first evaluates its expression. It then looks for the first case clause whose expression evaluates to the same value as the result of the input expression (using the strict comparison 446, (===) and transfers control to that clause, executing the associated statements. (If multiple cases match the provided value, the first case that matches is selected, even if the cases are not equal to each other.)

If no matching case clause is found, the program looks for the optional default clause, and if found, transfers control to that clause, executing the associated statements. If no default clause is found, the program continues execution at the statement following the end of switch. By convention, the default clause is the last clause, but it does not need to be so.

The optional break statement associated with each case label ensures that the program breaks out of switch once the matched statement is executed and continues execution at the statement following switch. If break is omitted, the program continues execution at the next statement in the switch statement.1

Hints
Hint 1
Remember that case values are tested with strict equality (===).

Try to solve the problem now!

Hint 2
Do not see “following conditions” as an ordered list as it looks in the original freeCodeCamp demo, but as values and statements, as shown here

Try to solve the problem now!

Solutions
Solution 1 (Click to Show/Hide)
function caseInSwitch(val) {
  let answer = "";
  // Only change code below this line
  switch (val) {
    case 1:
      answer = "alpha";
      break;
    case 2:
      answer = "beta";
      break;
    case 3:
      answer = "gamma";
      break;
    case 4:
      answer = "delta";
      break;
  }
  // Only change code above this line
  return answer;
}
// Change this value to test
caseInSwitch(1);
Code Explanation
Since you already have a variable defined at the beginning of the function named answer and it’s defined as the last return statement, you can assign new values to it for each case and will return the expected answer depending on the value you pass to the function.

Relevant Links
1. Description of “switch” - MDN JavaScript reference 593.

Solution 2 (Click to Show/Hide)
function caseInSwitch(val) {
  switch (val) {
    case 1:
      return "alpha";
      break;
    case 2:
      return "beta";
      break;
    case 3:
      return "gamma";
      break;
    case 4:
      return "delta";
      break;
  }
}

// Change this value to test
caseInSwitch(1);
---------------
¡No contaban con tu astucia!
-------------
Agrega una opción predeterminada en las declaraciones switch
En una declaración switch puede que no seas capaz de especificar todos los valores posibles como declaraciones de case (caso). En su lugar, se puede añadir la declaración default, la cual se ejecutará si no se encuentran declaraciones case. Piensa en ella como la última sentencia else en una cadena if/else.

Una declaración default debe ser el último caso.

switch (num) {
  case value1:
    statement1;
    break;
  case value2:
    statement2;
    break;
...
  default:
    defaultStatement;
    break;
}
Escribe una declaración switch para establecer answer con las siguientes condiciones:
a - apple
b - bird
c - cat
default - stuff
------------
¡Te felicito!
-----------
Múltiples opciones idénticas en las declaraciones "switch"
Si la sentencia break es omitida en un caso (case) de una sentencia switch, las siguientes sentencias case serán ejecutadas hasta encontrar un break. Si tienes múltiples entradas con la misma salida, puedes representarlas en una sentencia switch como esta:

let result = "";
switch (val) {
  case 1:
  case 2:
  case 3:
    result = "1, 2, or 3";
    break;
  case 4:
    result = "4 alone";
}
Los casos 1, 2 y 3 producirán el mismo resultado.

Escribe una declaración switch para establecer answer con los siguientes rangos:
1-3 - Low
4-6 - Mid
7-9 - High

Nota: Necesitarás tener un case para cada número dentro del rango.
-----------
El Nirvana está llegando, el portal místico espera
----------
Reemplazando cadenas de "If Else" por "Switch"
Si tienes muchas opciones entre las que elegir, una sentencia switch puede ser más fácil de escribir que muchas sentencias if/else if encadenadas. Lo siguiente:

if (val === 1) {
  answer = "a";
} else if (val === 2) {
  answer = "b";
} else {
  answer = "c";
}
puede reemplazarse por:

switch (val) {
  case 1:
    answer = "a";
    break;
  case 2:
    answer = "b";
    break;
  default:
    answer = "c";
}
Cambia la cadena de sentencias if/else if por una sentencia switch.
-----------
¡Estallido supersónico!
-----------
Devuelve valores booleanos desde funciones
Puede recordar de la comparación con el operador de igualdad que todos los operadores de comparación devuelven un valor booleano true o false.

A veces la gente usa una sentencia if/else para hacer una comparación, como esta:

function isEqual(a, b) {
  if (a === b) {
    return true;
  } else {
    return false;
  }
}
Pero hay una mejor manera de hacer esto. Puesto que === devuelve true o false, podemos devolver el resultado de la comparación:

function isEqual(a, b) {
  return a === b;
}
Corrige la función isLess para eliminar las sentencias if/else.
--------
¡Objectivo destruido!
---------
Patrón de devolución anticipado para funciones
Cuando se alcanza una sentencia return, la ejecución de la función actual se detiene y el control se devuelve a la ubicación de la llamada.

Ejemplo

function myFun() {
  console.log("Hello");
  return "World";
  console.log("byebye")
}
myFun();
Lo anterior mostrará la cadena Hello en la consola y devolverá la cadena World. La cadena byebye nunca se mostrará en la consola, porque la función termina en la sentencia return.

Modifica la función abTest para que cuando a o b sean menores que 0 la función salga inmediatamente con un valor undefined.

Pista
Recuerda que undefined es una palabra clave, no una cadena.
------------
freeCodeCamp Challenge Guide: Return Early Pattern for Functions
Guide

camperbot
Great contributor

9
Oct '19
Return Early Pattern for Functions 137
Hints
Hint 1
We need to modify the function abTest so that if a or b are less than 0 the function will immediately exit with a value of undefined.

We add in body of function simple if statement, which, under the conditions "if a or b are less than 0 - immediately exit with a value of undefined":

if (a < 0 || b < 0) {
  return undefined;
}
Hint 2
Now, if a or b are less than 0 - function exit with a value of undefined, in other cases -

return Math.round(Math.pow(Math.sqrt(a) + Math.sqrt(b), 2));
Solutions
Solution 1 (Click to Show/Hide)
// Setup
function abTest(a, b) {
  // Only change code below this line
  if (a < 0 || b < 0) {
    return undefined;
  }

  // Only change code above this line

  return Math.round(Math.pow(Math.sqrt(a) + Math.sqrt(b), 2));
}

// Change values below to test your code
abTest(2, 2);
------------
¡Con calma y a codificar!
-------------
Conteo de cartas
En el juego de casino Blackjack, un jugador puede determinar si tiene una ventaja en la siguiente mano sobre la casa llevando la cuenta del número relativo de cartas altas y bajas que quedan en la baraja. Esto se llama cuenta de tarjetas.

Tener más cartas altas en la baraja es una ventaja para el jugador. Se le asigna un valor a cada carta de acuerdo a la siguiente tabla. Cuando el conteo es positivo, el jugador debería apostar alto. Cuando el conteo da 0 o negativo, el jugador debería apostar bajo.

Cambios del conteo	Cartas
+1	2, 3, 4, 5, 6
0	7, 8, 9
-1	10, 'J', 'Q', 'K', 'A'
Escribirás una función para contar cartas. Recibirá un parámetro card (carta) que puede ser un número o una cadena y aumentar o reducir la variable global count (conteo) de acuerdo al valor de la carta (observa la tabla). La función devolverá una cadena con el conteo actual y la cadena Bet (Apuesta) si el conteo es positivo, o Hold (Espera) si el conteo es cero o negativo. El conteo actual y la decisión del jugador (Bet o Hold) deben estar separados por un solo espacio.

Resultados de ejemplo: -3 Hold o 5 Bet

Sugerencia
NO reinicies count a 0 cuando el valor sea 7, 8 o 9. NO devuelvas un arreglo.
NO incluyas comillas (individuales o dobles) en el resultado.
--------------
Counting Cards 521
Hints
Hint 1
Use a switch (or else if) statement to count the value of each card.

Hint 2
Add/subtract the value of each card to variable count. If the card is worth 0, don’t do anything.

Hint 3
After you’ve counted the cards, use an if statement to check the value of count. Also, make sure your return has a space between the number and the string.

Solutions
Solution 1 (Click to Show/Hide)
let count = 0;

function cc(card) {
  // Only change code below this line
  switch (card) {
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
      count++;
      break;
    case 10:
    case "J":
    case "Q":
    case "K":
    case "A":
      count--;
      break;
  }
  if (count > 0) {
    return count + " Bet";
  } else {
    return count + " Hold";
  }
  // Only change code above this line
}

cc(2); cc(3); cc(7); cc('K'); cc('A');
Code Explanation
Check the value of each card via a switch statement.
The variable count:
Increases by 1 if the card is a 2, 3, 4, 5, or 6.
Since 7, 8, and 9 aren’t worth anything, we ignore those cards in our switch statement.
Decreases by 1 if the card is a 10, ‘J’, ‘Q’, ‘K’, or ‘A’.
Check the value of count and return the appropriate response.
Example Run

cc(2); runs.
The switch statement hits case 2, jumps down and adds 1 to the variable count.
The switch statement then hits the break and cc(3); runs.
This cycle continues until the final call is made, cc('A');.
After the switch statement, the if statement checks count, which is now 0.
This then drops down to the else statement, which will return 0 Hold.
Note: As mentioned earlier, the switch statement could have also been an else if statement.

Solution 2 (Click to Show/Hide)
function cc(card) {
  // Only change code below this line
  var regex = /[JQKA]/;
  if (card > 1 && card < 7) {
    count++;
  } else if (card === 10 || regex.test(card)) {
    count--;
  }

  if (count > 0) return count + " Bet";
  return count + " Hold";

  // Only change code above this line
}
Code Explanation
· The function first evaluates if the condition card is a value greater than 1 and lower than 7, in which case it increments count by one.
· Then if the card is 10 or higher it decrements count by one.
· The variable regex is a regular expression 2.1k representing values (letters) for the higher cards.
· The else statement checks those values with the || (logical OR) operator; first for 10 and then for any string that matches the regular expression using String.match() 496.

Relevant Links
Card counting at Wikipedia 917
Challenge: Selecting from many options with Switch Statements 1.4k
Challenge: Chaining If Else Statements 954
Challenge: Increment a Number with JavaScript 1.5k
---------
¡Supercalifragilísticoespialidoso!
------
Construye objetos en JavaScript
Es posible que hayas escuchado el término objeto (object) antes.

Los objetos son similares a los arreglos (arrays), excepto que en lugar de usar índices para acceder y modificar sus datos, accedes a los datos en objetos a través de propiedades (properties).

Los objetos son útiles para almacenar datos de forma estructurada y pueden representar objetos del mundo real, como un gato.

Por ejemplo, aquí hay un objeto de gato:

const cat = {
  "name": "Whiskers",
  "legs": 4,
  "tails": 1,
  "enemies": ["Water", "Dogs"]
};
En este ejemplo, todas las propiedades se almacenan como cadenas, como name, legs y tails. Sin embargo, también puedes utilizar números como propiedades. Incluso puedes omitir las comillas para las propiedades de cadenas de una sola palabra, de la siguiente manera:

const anotherObject = {
  make: "Ford",
  5: "five",
  "model": "focus"
};
Sin embargo, si tu objeto tiene propiedades que no son cadenas, JavaScript las convertirá automáticamente en cadenas.

Crea un objeto que represente a un perro llamado myDog que contenga las propiedades name (una cadena), legs, tails y friends.
Puedes establecer estas propiedades del objeto a los valores que quieras, siempre y cuando name sea una cadena, legs y tails sean números, y friends sea un arreglo.
---------------
¡Fuera de serie!
------------
Accede a propiedades de objetos con notación de puntos
Hay dos maneras de acceder a las propiedades de un objeto: notación de puntos (.) y notación de corchetes ([]), similar a un arreglo.

La notación de puntos es lo que se usa cuando conoces el nombre de la propiedad a la que intentas acceder con antelación.

Aquí hay un ejemplo de cómo usar la notación de puntos (.) para leer la propiedad de un objeto:

const myObj = {
  prop1: "val1",
  prop2: "val2"
};

const prop1val = myObj.prop1;
const prop2val = myObj.prop2;
prop1val tendrá una cadena con valor val1 y prop2val tendrá una cadena con valor val2.

Lee los valores de las propiedades de testObj utilizando la notación de puntos. Asigna la variable hatValue igual a la propiedad hat del objeto y asigna la variable shirtValue igual a la propiedad shirt del objeto.
-----
¡Lo hiciste!
---------
Accede a propiedades de objetos con notación de corchete
La segunda manera de acceder a las propiedades de un objeto es con la notación de corchetes ([]). Si la propiedad del objeto al que intentas acceder tiene un espacio en el nombre, necesitarás usar notación de corchetes.

Sin embargo, también puedes utilizar la notación de corchetes en las propiedades de objeto sin espacios.

Aquí hay un ejemplo de cómo usar la notación de corchetes para leer la propiedad de un objeto:

const myObj = {
  "Space Name": "Kirk",
  "More Space": "Spock",
  "NoSpace": "USS Enterprise"
};

myObj["Space Name"];
myObj['More Space'];
myObj["NoSpace"];
myObj["Space Name"] sería la cadena Kirk, myObj['More Space'] sería la cadena Spock, y myObj["NoSpace"] sería la cadena USS Enterprise.

Ten en cuenta que los nombres de las propiedades con espacios deben estar entre comillas (simples o dobles).

Lee los valores de las propiedades an entree y the drink de testObj usando la notación de corchetes y asígnalos a entreeValue y drinkValue respectivamente.
---------------
¡Por el poder de Grayskull!
--------------
Accede a propiedades de objetos con variables
Otro uso de la notación de corchetes en objetos es acceder a una propiedad que está almacenada como el valor de una variable. Esto puede ser muy útil para iterar a través de las propiedades de un objeto o para acceder a una tabla de búsqueda.

Aquí hay un ejemplo del uso de una variable para acceder a una propiedad:

const dogs = {
  Fido: "Mutt",
  Hunter: "Doberman",
  Snoopie: "Beagle"
};

const myDog = "Hunter";
const myBreed = dogs[myDog];
console.log(myBreed);
La cadena Doberman se mostrará en la consola.

Ten en cuenta que no utilizamos comillas alrededor del nombre de la variable cuando la usamos para acceder a la propiedad porque utilizamos el valor de la variable, no el nombre.

Asigna la variable playerNumber a 16. Luego, usa la variable para buscar el nombre del jugador y asignarlo a player.
------------
¡Bingo!
------------
Actualizando las propiedades de un objeto
Después de haber creado un objeto de JavaScript, puedes actualizar sus propiedades en cualquier momento tal y como actualizarías cualquier otra variable. Puedes utilizar tanto la notación de puntos como la notación de corchetes para actualizar.

Por ejemplo, veamos ourDog:

const ourDog = {
  "name": "Camper",
  "legs": 4,
  "tails": 1,
  "friends": ["everything!"]
};
Puesto que es un perro particularmente feliz, vamos a cambiar su nombre por la cadena Happy Camper. Así es como actualizamos la propiedad del nombre del objeto: ourDog.name = "Happy Camper"; o ourDog["name"] = "Happy Camper";. Ahora cuando evaluamos ourDog.name, en lugar de obtener Camper, vamos a obtener su nuevo nombre, Happy Camper.

Actualiza la propiedad nombre del objeto myDog. Cambiemos su nombre de Coder a Happy Coder. Puedes utilizar tanto la notación de puntos como la notación de corchetes.
-------
¡Estallido supersónico!
--------
Añade nuevas propiedades a un objeto de JavaScript
Puedes añadir nuevas propiedades a los objetos de JavaScript existentes de la misma manera que los modificarías.

Así es como podríamos agregar una propiedad bark a nuestro objeto ourDog:

ourDog.bark = "bow-wow";
o

ourDog["bark"] = "bow-wow";
Ahora cuando evaluemos ourDog.bark, obtendremos su ladrido, bow-wow.

Por ejemplo:

const ourDog = {
  "name": "Camper",
  "legs": 4,
  "tails": 1,
  "friends": ["everything!"]
};

ourDog.bark = "bow-wow";
Añade una propiedad bark a myDog y establécela a un sonido de perro, como "woof". Puedes usar tanto la notación de puntos como la notación de corchetes.
----------
¡Supercalifragilísticoespialidoso!
------------
Elimina propiedades en un objeto de JavaScript
También podemos eliminar propiedades de objetos de esta forma:

delete ourDog.bark;
Ejemplo:

const ourDog = {
  "name": "Camper",
  "legs": 4,
  "tails": 1,
  "friends": ["everything!"],
  "bark": "bow-wow"
};

delete ourDog.bark;
Después de la última línea mostrada anteriormente, ourDog se ve así:

{
  "name": "Camper",
  "legs": 4,
  "tails": 1,
  "friends": ["everything!"]
}
Elimina la propiedad tails de myDog. Puedes usar tanto la notación de puntos como la notación de corchetes.
-----------
¡Tienes agallas!
------------
Usa objetos para hacer búsquedas
Los objetos pueden ser considerados como un almacenamiento clave/valor, como un diccionario. Si tienes datos tabulares, puedes utilizar un objeto para hacer una búsqueda de valores en lugar de una declaración switch o encadenar if/else. Esto es de mucha utilidad cuando se sabe que los datos de entrada están limitados a un cierto rango.

Aquí hay un ejemplo de una simple búsqueda de alfabeto inverso:

const alpha = {
  1:"Z",
  2:"Y",
  3:"X",
  4:"W",
  ...
  24:"C",
  25:"B",
  26:"A"
};

const thirdLetter = alpha[2];
const lastLetter = alpha[24];

const value = 2;
const valueLookup = alpha[value];
thirdLetter es la cadena Y, lastLetter es la cadena C, y valueLookup es la cadena Y.

Convierte la declaración switch en un objeto llamado lookup. Úsalo para buscar val y asignar la cadena asociada a la variable result.
-----------
Using Objects for Lookups 895
Solutions
Solution 1 (Click to Show/Hide)
function phoneticLookup(val) {
  var result = "";
  var lookup = {
    "alpha": "Adams",
    "bravo": "Boston",
    "charlie": "Chicago",
    "delta": "Denver",
    "echo": "Easy",
    "foxtrot": "Frank"
  };
// After converting our case statements into object properties you can make use of the variable `result` to let the function return the correct value.


  result = lookup[val];
  // Only change code above this line
  return result;
}
Relevant Links
“JavaScript object basics” - MDN JavaScript reference 
-----------
Thundercats, ¡guooooo!
----------
Verifica las propiedades de un objeto
A veces es útil comprobar si existe o no la propiedad de un objeto dado. Podemos utilizar el método .hasOwnProperty(propname) para determinar si un objeto tiene una propiedad con ese nombre. .hasOwnProperty() devuelve true o false si se encuentra la propiedad o no.

Por ejemplo

const myObj = {
  top: "hat",
  bottom: "pants"
};

myObj.hasOwnProperty("top");
myObj.hasOwnProperty("middle");
El primer hasOwnProperty devuelve true, mientras que el segundo devuelve false.

Modifica la función checkObj para verificar si el objeto obj pasado a la función contiene la propiedad checkProp. Si la propiedad es encontrada, devuelve el valor de la propiedad. Si no, devuelve "Not Found".
------------
Oct '21
Testing Objects for Properties 1.4k
Hints
You do not need to declare any additional variables or define any objects inside of your function. You must use the function arguments obj and checkProp.

Note: Old solutions found in replies to this post will not work. This challenge has been edited several times since 2017. Only the solution in this post is up to date.

Solutions
Solution 1 (Click to Show/Hide)

function checkObj(obj, checkProp) {
  if (obj.hasOwnProperty(checkProp)) {
    return obj[checkProp];
  } else {
    return "Not Found";
  }
}
-----------
Verifica las propiedades de un objeto
A veces es útil comprobar si existe o no la propiedad de un objeto dado. Podemos utilizar el método .hasOwnProperty(propname) para determinar si un objeto tiene una propiedad con ese nombre. .hasOwnProperty() devuelve true o false si se encuentra la propiedad o no.

Por ejemplo

const myObj = {
  top: "hat",
  bottom: "pants"
};

myObj.hasOwnProperty("top");
myObj.hasOwnProperty("middle");
El primer hasOwnProperty devuelve true, mientras que el segundo devuelve false.

Modifica la función checkObj para verificar si el objeto obj pasado a la función contiene la propiedad checkProp. Si la propiedad es encontrada, devuelve el valor de la propiedad. Si no, devuelve "Not Found".
----------------
freeCodeCamp Challenge Guide: Testing Objects for Properties
Guide

camperbot
Great contributor

13
Oct '21
Testing Objects for Properties 1.4k
Hints
You do not need to declare any additional variables or define any objects inside of your function. You must use the function arguments obj and checkProp.

Note: Old solutions found in replies to this post will not work. This challenge has been edited several times since 2017. Only the solution in this post is up to date.

Solutions
Solution 1 (Click to Show/Hide)

function checkObj(obj, checkProp) {
  if (obj.hasOwnProperty(checkProp)) {
    return obj[checkProp];
  } else {
    return "Not Found";
  }
}
---------------
¡Pikachu te elige a ti!
-----------------

freeCodeCamp Challenge Guide: Manipulating Complex Objects
Guide

camperbot
Great contributor

5
Oct '19
Manipulating Complex Objects 589
Solutions
Solution 1 (Click to Show/Hide)
After string // Add record here we add new album to the myMusic. You need to start from ,. And you can just copy already created album:

{
    "artist": "Billy Joel",
    "title": "Piano Man",
    "release_year": 1973,
    "formats": [ 
      "CD",
      "8T",
      "LP"
    ],
    "gold": true
  }
and paste after ,:

  // Add record here
  ,
  {
    "artist": "Billy Joel",
    "title": "Piano Man",
    "release_year": 1973,
    "formats": [ 
      "CD",
      "8T",
      "LP"
    ],
    "gold": true
  }
Now, you can change values your album:

  // Add record here
  ,
  {
    "artist": "Deep Purple",
    "title": "Smoke on the water",
    "release_year": 1976,
    "formats": [ 
      "CD",
      "8T",
      "LP"
    ],
    "gold": true
  }
];
Here’s a full solution:

var myMusic = [
  {
    artist: "Billy Joel",
    title: "Piano Man",
    release_year: 1973,
    formats: ["CD", "8T", "LP"],
    gold: true
  },
  // Add record here
  {
    artist: "Deep Purple",
    title: "Smoke on the water",
    release_year: 1976,
    formats: ["CD", "8T", "LP"]
  }
----------------
¡Al infinito, y más allá!
----------------
Accede a objetos anidados
Se puede acceder a las sub propiedades de objetos encadenando la notación de puntos o corchetes.

Aquí hay un objeto anidado:

const ourStorage = {
  "desk": {
    "drawer": "stapler"
  },
  "cabinet": {
    "top drawer": { 
      "folder1": "a file",
      "folder2": "secrets"
    },
    "bottom drawer": "soda"
  }
};

ourStorage.cabinet["top drawer"].folder2;
ourStorage.desk.drawer;
ourStorage.cabinet["top drawer"].folder2 sería la cadena secrets y ourStorage.desk.drawer sería la cadena stapler.

Accede al objeto myStorage y asigna el contenido de la propiedad glove box a la variable gloveBoxContents. Utiliza la notación de puntos para todas las propiedades cuando sea posible, de lo contrario utiliza la notación de corchetes.
--------
8
Jul 7
Accessing Nested Objects 181
Hints
Hint 1
Use bracket notation for properties with a space in their name.

If we look at our object:

const myStorage = {
  car: {
    inside: {
      "glove box": "maps",
      "passenger seat": "crumbs"
    },
    outside: {
      trunk: "jack"
    }
  }
};
Our object name is myStorage.

|-- Inside that we have a nested object called car.

|— Inside that we have two more called inside and outside each with their
own properties

You can visualize the object structure like this, if it helps:

myStorage
|-- car
|--- inside
|----- glove box: maps
|----- passenger seat: crumbs
|--- outside
|----- trunk: jack
We are asked to assign the contents of glove box ,
which we can see is nested in the inside object,
which in turn, is nested in the car object.

We can use dot notation to access the glove box as follows:

const gloveBoxContents = myStorage.car.inside[complete here]
You must replace complete here with the correct way to access the property.
See clue above if you get stuck.
----------
¡Esto es pan comido!
----------
Accede a arreglos anidados
Como hemos visto en ejemplos anteriores, los objetos pueden contener tanto objetos anidados como así también arreglos anidados. De manera similar a como se accede a los objetos anidados, la notación de corchetes de arreglos puede ser encadenada para acceder a arreglos anidados.

En el siguiente ejemplo, vemos cómo se accede a un arreglo anidado:

const ourPets = [
  {
    animalType: "cat",
    names: [
      "Meowzer",
      "Fluffy",
      "Kit-Cat"
    ]
  },
  {
    animalType: "dog",
    names: [
      "Spot",
      "Bowser",
      "Frankie"
    ]
  }
];

ourPets[0].names[1];
ourPets[1].names[0];
ourPets[0].names[1] sería la cadena Fluffy, y ourPets[1].names[0] sería la cadena Spot.

Utilizando la notación de puntos y corchetes, establezca la variable secondTree en el segundo elemento de la lista trees del objeto myPlants.

-------------
¡Bingo!
-------------
Colección de discos
Se te da un objeto literal que representa una parte de tu colección de álbumes musicales. Cada álbum tiene un número de id único como clave y varias otras propiedades. No todos los álbumes tienen una información completa.

Empiezas con una función updateRecords la cual toma un objeto literal, records, que contiene el álbum musical de la colección, un id, prop (como artist o tracks), y value. Completa la función usando las reglas siguientes para modificar el objeto pasado a la función.

Tu función siempre debe devolver el objeto de colección de registros completo.
Si prop no es tracks y value no es una cadena vacía, actualiza o establece la propiedad prop del album a value.
Si prop es tracks pero el álbum no tiene una propiedad tracks, crea un arreglo vacío y agrégale value a él.
Si prop es tracks y value no es una cadena vacía, agrega value al final del arreglo de tracks existentes del álbum.
Si value es una cadena vacía, elimina esa propiedad prop del álbum.
Nota: Se usa una copia del objeto recordCollection para las pruebas.
---------
Jul 27
Record Collection 1.2k
Problem Explanation
For the given id parameter, which is associated with the records object:
* If the value parameter isn’t an empty string, update (or set) the value parameter for the prop parameter.
* If the prop parameter is equal to "tracks" and the value isn’t an empty string, push the value onto the end of the tracks array.
* If value is an empty string, delete that prop from the object.

Finally, return records.
Hints
Hint 1
Use an if...else if chain to check the needed steps.

Hint 2
To access the value of a key in this object, you will use records[id][prop].

Hint 3
You can’t push to an array that doesn’t exist. Use hasOwnProperty to check first.

Solutions
 Solution 1 (Click to Show/Hide)
function updateRecords(records, id, prop, value) {
  if (prop !== 'tracks' && value !== "") {
    records[id][prop] = value;
  } else if (prop === "tracks" && records[id].hasOwnProperty("tracks") === false) {
    records[id][prop] = [value];
  } else if (prop === "tracks" && value !== "") {
    records[id][prop].push(value);
  } else if (value === "") {
    delete records[id][prop];
  }
  return records;
}
 Solution 2 (Click to Show/Hide)
function updateRecords(records, id, prop, value) {
  if (value === '') {
    delete records[id][prop];
  } else if (prop === 'tracks') {
    records[id][prop] = records[id][prop] || []; // this is called shortcircuit evaluation, see below for explanation
    records[id][prop].push(value);
  } else {
    records[id][prop] = value;
  }
  return records;
}
Code Explanation
First checks if value is a blank string. If so, then the key (prop) is removed from the object.
If that first check doesn’t pass, it next checks if prop is equal to tracks. The tracks array is initialized if it does not exist, and then value is pushed into the tracks array. (This step uses shortcircuit evaluation)
If both these checks fail (meaning value is not an empty string and prop is not tracks), then either a new key (prop) and value (value) are added to the object, or an existing key is updated if the prop already exists.
Example Run

updateRecords(5439, "artist", "ABBA"); runs.
value is not a blank string, so the first condition of the else if statement fails.
prop is equal to “artist”, not “tracks”, so the second condition of the else if statement fails.
in the ‘else’ clause, artist: "ABBA" is added to the 5439 id.
Relevant Links
fCC’s challenge: Accessing Objects Properties with Bracket Notation 957
fCC’s challenge: Add New Properties to a JavaScript Object 345
fCC’s challenge: Delete Properties from a JavaScript Object 131
fCC’s challenge: Accessing Nested Objects 258
“Array.prototype.push()” - MDN JavaScript reference 287
“delete operator” - MDN JavaScript reference 188
shortcircuit evaluation 1.4k
 Solution 3 (Click to Show/Hide)
function updateRecords(records, id, prop, value) {
  // Access target album in record collection
  const album = records[id];

  // If value is an empty string,
  //  delete the given prop property from the album
  if (value === "") {
    delete album[prop];
  }
  // If prop isn't tracks,
  //  update or set that album's prop to value
  else if (prop !== "tracks") {
    album[prop] = value;
  }
  // If prop is tracks,
  //  add value to the end of the album's existing tracks array
  else {
    album["tracks"] = album["tracks"] || [];
    album["tracks"].push(value);
  }

  // Your function must always return the entire record collection object
  return records;
}
This solution uses the fact that objects are stored as references to slightly simplify the solution syntax.
---------------
¡Buena esa!
---------------
Itera con el bucle "while" de JavaScript
Puedes ejecutar el mismo código múltiples veces usando un bucle.

El primer tipo de bucle que aprenderemos se llama bucle while porque ejecuta una condición específica mientras esta sea verdadera, y se detiene una vez que esa condición ya no sea verdadera.

const ourArray = [];
let i = 0;

while (i < 5) {
  ourArray.push(i);
  i++;
}
En el ejemplo de código anterior, el bucle while se ejecutará 5 veces y añadirá los números de 0 a 4 a ourArray.

Intentemos construir un bucle while para que funcione empujando valores a un arreglo.

Agrega los números de 5 a 0 (inclusivo) en orden descendente a myArray usando un bucle while.
-----------
Iterate with JavaScript While Loops 168
Problem Explanation
While loops will run as long as the condition inside the ( ) is true.

Example:

while (condition) {
  //code...
}
Hints
Hint 1
Use a iterator variable such as i in your condition

let i = 5;
while (i  >= 0) {}
Solutions
Solution 1 (Click to Show/Hide)
// Setup
const myArray = [];

// Only change code below this line.
let i = 5;
while(i >= 0) {
  myArray.push(i);
  i--;
}
-----------
¡Tienes una cita con el destino!
---------
Itera con los bucles "for" de JavaScript
Puedes ejecutar el mismo código múltiples veces usando un bucle.

El tipo más común de bucle de JavaScript se llama bucle for porque se ejecuta "por" un número específico de veces.

Los bucles for se declaran con tres expresiones opcionales separadas por punto y coma:

for (a; b; c), donde a es la sentencia de inicialización, b es la sentencia condicional, y c es la expresión final.

La sentencia de inicialización se ejecuta una sola vez antes de que el bucle comience. Normalmente se utiliza para definir y configurar tu variable de bucle.

La sentencia condicional es evaluada al principio de cada iteración del bucle y continuará siempre y cuando sea true. Cuando la condición sea false al inicio de la iteración, el bucle dejará de ejecutarse. Esto significa que si la condición comienza como falso, tu bucle nunca se ejecutará.

La expresión final se ejecuta al final de cada iteración del bucle, antes de la siguiente comprobación de condición y se utiliza normalmente para incrementar o disminuir tu contador de bucle.

En el siguiente ejemplo inicializamos con i = 0 e iteramos mientras nuestra condición i < 5 es verdadera. Incrementaremos i por 1 en cada iteración de bucle con i++ como nuestra expresión final.

const ourArray = [];

for (let i = 0; i < 5; i++) {
  ourArray.push(i);
}
ourArray ahora tendrá el valor [0, 1, 2, 3, 4].

Usa un bucle for para empujar los valores desde el 1 al 5 en myArray.
---------
// Configuración
const myArray = [];

// Cambia solo el código debajo de esta línea
for(let i = 1; i < 6; i++){
  myArray.push(i);
}
----------
Programa mucho y prospera
------------
Los bucles "for" no tienen que iterar de uno en uno a la vez. Al cambiar nuestra final-expression (expresión final), podemos contar con números pares.

Empezaremos en i = 0 y realizaremos el bucle mientras i < 10. Incrementaremos i en 2 cada bucle utilizando i += 2.

const ourArray = [];

for (let i = 0; i < 10; i += 2) {
  ourArray.push(i);
}
ourArray ahora contendrá [0, 2, 4, 6, 8]. Cambiemos nuestra initialization (inicialización) para que podamos contar por números impares.

Inserta los números impares desde 1 hasta 9 en myArray utilizando un bucle for.
-------------
// Configuración
const myArray = [];

// Cambia solo el código debajo de esta línea
for(let i = 1; i < 11; i +=2){
  myArray.push(i);
}
-----------
¡Estás en llamas!
-----------
Cuenta hacia atrás con un bucle "for"
Un bucle for también puede contar hacia atrás, siempre que definamos las condiciones adecuadas.

Para poder disminuirle dos cada iteración, necesitaremos cambiar nuestra inicialización, condición, y expresión final.

Empezaremos en i = 10 e iteraremos mientras i > 0. Disminuiremos i en 2 por cada bucle con i -= 2.

const ourArray = [];

for (let i = 10; i > 0; i -= 2) {
  ourArray.push(i);
}
ourArray ahora contendrá [10, 8, 6, 4, 2]. Ahora cambiemos el valor de inicialización y la expresión final de nuestro bucle para que podamos contar hacia atrás de dos en dos y así crear un arreglo descendente de números impares.

Inserta los números impares desde el 9 hasta el 1 en myArray utilizando un bucle for.
-------------
// Configuración
const myArray = [];

// Cambia solo el código debajo de esta línea
for(let i= 9; i > 0; i-=2){
  myArray.push(i);
}
-----------
Reclama la propiedad de tus sueños!
--------
Itera a través de un arreglo con un bucle "for"
Una tarea común en JavaScript es iterar a través del contenido de un arreglo. Una forma de hacerlo es con un bucle for. Este código mostrará cada elemento del arreglo arr en la consola:

const arr = [10, 9, 8, 7, 6];

for (let i = 0; i < arr.length; i++) {
   console.log(arr[i]);
}
Recuerda que los arreglos tienen una indexación basada en cero, lo que significa que el último índice del arreglo es igual a su longitud menos uno (length - 1). Nuestra condición para este bucle es i < arr.length, que detiene el bucle cuando i es igual a length. En este caso, la última iteración es i === 4, es decir, cuando i se convierte en igual a arr.length - 1 y resultados 6 a la consola. Entonces i aumenta a 5, y el bucle termina i < arr.length es false.

Declara e inicializa una variable total a 0. Usa un bucle for para sumar el valor de cada elemento del arreglo myArr al total.
--------
freeCodeCamp Challenge Guide: Iterate Through an Array with a For Loop
Guide

camperbot
Great contributor

9
Jan 21
Iterate Through an Array with a For Loop 204
Hints
Hint 1
Remember the structure of a for loop:
for ([initialization]; [condition]; [final-expression]) statement

The [initialization] part is executed only once (the first time).
The [condition] is checked on every iteration.
The [final-expression] is executed along the statement if [condition] resolves to true.
Hint 2
Remember how accumulators work:
let x += i

The variable x is going to act as the accumulator.
The variable i is the one which value will be stored (and accumulated) inside x
The expression += is an just abbreviation of x = x + i
Solutions
Solution 1 (Click to Show/Hide)
let total = 0;
for (let i = 0; i < myArr.length; i++) {
  total += myArr[i];
}
Code Explanation
Initialization: i gets a value of 0 and its used as a counter.
Condition: the subsequent code is executed as long as i is lower than the length of myArr (which is 5; five numbers but arrays are zero based).
Final-expression: i is incremented by 1.
Statement: The function adds myArr[i]'s value to total until the condition isn’t met like so:
total + myArr[0] -> 0 + 2 = 2 
total + myArr[1] -> 2 + 3 = 5
total + myArr[2] -> 5 + 4 = 9
total + myArr[3] -> 9 + 5 = 14 
total + myArr[4] -> 14 + 6 = 20
Solution 2 (Click to Show/Hide)
let total = 0;
for (let i = myArr.length - 1; i >= 0; i--) {
  total += myArr[i];
}
Code Explanation
This works similarly to the last solution.

Initialization: i is initialized with the value myArr.length - 1.
Condition: the loop is executed as long as i is greater than or equal to 0.
Final-expression: i is decremented by 1.
Statement: The function adds myArr[i]'s value to total until the condition isn’t met:
total + myArr[4] -> 0 + 6 = 6
total + myArr[3] -> 6 + 5 = 11
total + myArr[2] -> 11 + 4 = 15
total + myArr[1] -> 15 + 3 = 18
total + myArr[0] -> 18 + 2 = 20
Relevant Links
“for” - MDN JavaScript reference 156
--------
// Configuración
const myArr = [2, 3, 4, 5, 6];

// Cambia solo el código debajo de esta línea
let total=0;
for(let i = 0; i < myArr.length; i++){
  total+=myArr[i];
}
-----------
¡Te felicito!
------------
Anida bucles "for"
Si tienes un arreglo multidimensional, puedes utilizar la misma lógica que aprendimos anteriormente para recorrer tanto el arreglo como cualquier sub-arreglo. Aquí hay un ejemplo:

const arr = [
  [1, 2], [3, 4], [5, 6]
];

for (let i = 0; i < arr.length; i++) {
  for (let j = 0; j < arr[i].length; j++) {
    console.log(arr[i][j]);
  }
}
Esto imprime cada sub-elemento dentro de arr uno a la vez. Ten en cuenta que para el bucle interior, estamos comprobando el .length de arr[i], ya que arr[i] es en sí mismo es un arreglo.

Modifica la función multiplyAll para que devuelva el producto de todos los números dentro de los sub-arreglos de arr.
---------
freeCodeCamp Challenge Guide: Nesting For Loops
Guide

camperbot
Great contributor

7
Oct '19
Nesting For Loops 218
Problem Explanation
Relevant Links
Nest One Array Within Another Array 1.6k
Iterate Through An Array With A For Loop 1.1k
Accessing Nested Arrays 993
Hints
Hint 1
Make sure to check with length and not the overall array.

Hint 2
Use both i and j when multiplying the product.

Hint 3
Remember to use arr[i] when you multiply the sub-arrays with the product variable.

Solutions
Solution 1 (Click to Show/Hide)
function multiplyAll(arr) {
  var product = 1;
  // Only change code below this line
  for (var i = 0; i < arr.length; i++) {
    for (var j = 0; j < arr[i].length; j++) {
      product = product * arr[i][j];
    }
  }
  // Only change code above this line
  return product;
}

// Modify values below to test your code
multiplyAll([[1, 2], [3, 4], [5, 6, 7]]);
Code Explanation
We check the length of arr in the i for loop and the arr[i] length in the j for loop.
We multiply the product variable by itself because it equals 1, and then multiply it by the sub-arrays.
The two sub-arrays to multiply are arr[i] and j.
------------
¡Una para los Récords Guinness!
-----------
Itera con el bucle "do...while" de JavaScript
El siguiente tipo de bucle que aprenderás se llama bucle do...while. Se llama bucle do...while porque primero hace (do) una pasada por el código dentro del bucle sin importar qué, y luego continua ejecutando el bucle mientras (while) la condición especificada sea verdadera (true).

const ourArray = [];
let i = 0;

do {
  ourArray.push(i);
  i++;
} while (i < 5);
El ejemplo anterior se comporta de forma similar a otros tipos de bucles, siendo el arreglo resultante [0, 1, 2, 3, 4]. Sin embargo, lo que hace que el bucle do...while sea diferente a otros bucles es cómo se comporta cuando la condición falla en la primera verificación. Veamos esto en acción. Aquí hay un bucle while normal que ejecutara el código en el bucle mientras i < 5:

const ourArray = []; 
let i = 5;

while (i < 5) {
  ourArray.push(i);
  i++;
}
En este ejemplo, inicializamos el valor de ourArray a un arreglo vacío y el valor de i a 5. Cuando ejecutamos el bucle while, la condición se evalúa como false porque i no es inferior a 5, así que no ejecutamos el código dentro del bucle. El resultado es que ourArray terminará sin valores añadidos, y todavía se verá como [] una vez el código del ejemplo anterior haya terminado de ejecutarse. Ahora, dale un vistazo a un bucle do...while:

const ourArray = []; 
let i = 5;

do {
  ourArray.push(i);
  i++;
} while (i < 5);
En este caso, inicializamos el valor de i a 5, tal como lo hicimos en el bucle while. Cuando lleguemos a la siguiente línea, no hay ninguna condición para evaluar, así que entramos al código dentro de las llaves y se ejecuta. Añadiremos un único elemento al arreglo y luego incrementaremos i antes de llegar a la verificación de la condición. Cuando finalmente evaluamos la condición i < 5 en la última línea, vemos que el valor de i es ahora 6, por lo que falla la comprobación condicional. Salimos del bucle y hemos terminado. Al final del ejemplo anterior, el valor de ourArray es [5]. Esencialmente, un bucle do...while asegura que el código dentro del bucle se ejecute al menos una vez. Intentemos construir un bucle do...while para que funcione empujando valores a un arreglo.

Cambia el bucle while en el código por un bucle do...while. El bucle solo enviará el número 10 a myArray, e i será igual a 11 cuando tu código haya terminado de ejecutarse.
----------
ásico
Reemplaza bucles usando recursión
La recursión es el concepto que una función puede expresarse en términos de sí misma. Para ayudar a comprender esto, comienza pensando en la siguiente tarea: multiplica los primeros n elementos de un arreglo para crear el producto de esos elementos. Usando un bucle for, puedes hacer esto:

  function multiply(arr, n) {
    let product = 1;
    for (let i = 0; i < n; i++) {
      product *= arr[i];
    }
    return product;
  }
Sin embargo, nota que multiply(arr, n) == multiply(arr, n - 1) * arr[n - 1]. Esto significa que puedes reescribir multiply en términos de sí misma y que nunca necesites hacer uso de un bucle.

  function multiply(arr, n) {
    if (n <= 0) {
      return 1;
    } else {
      return multiply(arr, n - 1) * arr[n - 1];
    }
  }
La versión recursiva de multiply se desglosa así. En el caso base, donde n <= 0, devuelve 1. Para valores más grandes de n, se llama a sí misma, pero con n - 1. Esa llamada de función se evalúa de la misma manera, llamando a multiply otra vez hasta que n <= 0. En este punto, todas las funciones pueden devolver y la multiply original devuelve la respuesta.

Nota: Las funciones recursivas deben tener un caso base cuando devuelven sin tener que llamar a la función de nuevo (en este ejemplo, cuando n <= 0), de lo contrario nunca podrán terminar de ejecutarse.

Escribe una función recursiva, sum(arr, n), que devuelve la suma de los primeros elementos n de un arreglo arr.
-------------------------
freeCodeCamp Challenge Guide: Replace Loops using Recursion
Guide

camperbot
Great contributor

3
Feb '20
Replace Loops using Recursion 1.3k
Hints
Hint 1:
When n <= 0 sum(arr, n) returns 0.

Hint 2:
When n is larger than 0 sum(arr, n) returns sum(arr, n - 1) + arr[n - 1]

Solutions:
(Click to reveal)
function sum(arr, n) {
  if(n <= 0) {
    return 0;
  } else {
    return sum(arr, n - 1) + arr[n - 1];
  }
}
Code Explanation
The if statement checks to see if sum is evaluating the base case, n <= 0, or not. If it is, then sum returns the answer, 0 - the sum of elements from 0 to 0 inclusive. Otherwise, it recurses by evaluating a simpler function call, sum(arr, n - 1). Once that returns it adds a single array element, arr[n - 1], to it and returns that sum.

Resources
Recursive Functions - MDN JavaScript reference 5.0k
heart
+1
open_mouth
105
------------
¡Siente la velocidad!
------------
Búsqueda de perfiles
Tenemos un arreglo de objetos que representan a diferentes personas en nuestras listas de contactos.

Una función lookUpProfile que recibe nombre (name) y una propiedad (prop) como argumentos preescritos para ti.

La función debe verificar si el nombre (name) es el nombre de pila del contacto (firstName) y la propiedad (prop) dada es una propiedad de ese contacto.

Si ambos son verdaderos, entonces devolver el "valor" de esa propiedad.

Si name no corresponde a ningún contacto, entonces devuelve la cadena No such contact.

Si prop no corresponde a ninguna propiedad válida de un contacto encontrado que coincida con name entonces devuelve la cadena No such property.
----------------

ADVERTISEMENT

freeCodeCamp Challenge Guide: Profile Lookup
Guide

camperbot
Great contributor

10
Jan '21
Profile Lookup 485
Problem Explanation
Change the code below // Only change code below this line and up to // Only change code above this line.
Ensure that you are editing the inside of the lookUpProfile() function.
This function includes two parameters, firstName and prop.
The function should look through the contacts list for the given firstName parameter.
If there is a match found, the function should then look for the given prop parameter.
If both firstName and the associated prop are found, you should return the value of the prop.
If firstName is found and no associated prop is found, you should return No such property.
If firstName isn’t found anywhere, you should return No such contact.
Hints
Hint 1
Use a for loop to cycle through the contacts list.

Hint 2
Use a nested if statement to first check if the firstName matches, and then checks if the prop matches.

Hint 3
Leave your return "No such contact" out of the for loop as a final catch-all.

Solutions
Solution 1 (Click to Show/Hide)
function lookUpProfile(name, prop) {
  for (let x = 0; x < contacts.length; x++) {
    if (contacts[x].firstName === name) {
      if (contacts[x].hasOwnProperty(prop)) {
        return contacts[x][prop];
      } else {
        return "No such property";
      }
    }
  }
  return "No such contact";
}
Code Explanation
The for loop runs, starting at the first object in the contacts list.
If the firstName parameter passed into the function matches the value of the "firstName" key in the first object, the if statement passes.
Then, we use .hasOwnProperty() method (checks if there’s a given property and returns a boolean) with prop as an argument. If it’s true, the value of prop is returned.
If the second if statement fails, No such property is returned.
If the first if statement fails, the for loop continues on to the next object in the contacts list.
If the firstName parameter isn’t matched by the final contacts object, the for loop exits and No such contact is returned.
Example Run

lookUpProfile("Akira","likes"); runs.
"Akira" is matched to the "firstName" key in the first object, so the if statement returns true.
"likes" is found within the first object, so the second if statement returns true.
The value of "likes" is returned - "Pizza", "Coding", "Brownie Points".
Solution 2 (Click to Show/Hide)
function lookUpProfile(name, prop) {
  for (let i = 0; i < contacts.length; i++) {
    if (contacts[i].firstName === name) {
      if (prop in contacts[i]) {
        return contacts[i][prop];
      } else {
        return "No such property";
      }
    }
  }
  return "No such contact";
}
Code Explanation
This works as the last example but uses the in operator to look for prop instead of the hasOwnProperty() method.

Relevant Links
“Iterate with JavaScript For Loops” - fCC’s challenge 295
“Object.prototype.hasOwnProperty()” - MDN JavaScript reference 178
“in operator” - MDN JavaScript reference 443
---------------
¡Siente la velocidad!
-------------
Genera fracciones aleatorias con JavaScript
Los números aleatorios son útiles para crear comportamientos aleatorios.

JavaScript tiene una función Math.random() que genera un número decimal aleatorio entre 0 (inclusivo) y 1 (exclusivo). Así que Math.random() puede devolver un 0 pero nunca devuelve un 1.

Nota: Al igual que el almacenamiento de valores con el operador de asignación, todas las llamadas a la función se resolverán antes de que se ejecute el return, por lo que el return devuelve el valor de la función Math.random().

Cambia randomFraction para que devuelva un número aleatorio en lugar de devolver 0.
-----------
freeCodeCamp Challenge Guide: Generate Random Fractions with JavaScript
Guide

camperbot
Great contributor

9
Oct '19
Generate Random Fractions with JavaScript 182
Solutions
Solution 1 (Click to Show/Hide)
function randomFraction() {
  // Only change code below this line.
  var result = 0;
  // Math.random() can generate 0. We don't want to     return a 0,
  // so keep generating random numbers until we get one     that isn't 0
  while (result === 0) {
    result = Math.random();
  }

  return result;
  // Only change code above this line.
}
-------------
¡Eres lo máximo!
--------------
Genera números enteros aleatorios con JavaScript
Es genial que podamos generar números decimales aleatorios, pero es incluso más útil si lo usamos para generar números enteros aleatorios.

Usa Math.random() para generar un decimal aleatorio.
Multiplica ese decimal aleatorio por 20.
Utiliza otra función, Math.floor() para redondear el número hacia abajo a su número entero más cercano.
Recuerda que Math.random() nunca devolverá un 1 y porque estamos redondeando hacia abajo, es imposible obtener 20. Esta técnica nos dará un número entero entre 0 y 19.

Poniendo todo junto, así es como se ve nuestro código:

Math.floor(Math.random() * 20);
Estamos llamando a Math.random(), multiplicando el resultado por 20 y pasando el valor a la función Math.floor() para redondear el valor hacia abajo al número entero más cercano.

Utiliza esta técnica para generar y devolver un número entero aleatorio entre 0 y 9.

----------------
freeCodeCamp Challenge Guide: Generate Random Whole Numbers with JavaScript
Guide

camperbot
Great contributor

5
Oct '19
Generate Random Whole Numbers with JavaScript 95
Solutions
Solution 1 (Click to Show/Hide)
var randomNumberBetween0and19 = Math.floor(Math.random() * 20);

function randomWholeNum() {
  // Only change code below this line.
  return Math.floor(Math.random() * 10);
}
Code Explanation
We need to use Math.floor() with Math.random() to generate and return a random whole number between 0 and 9.
Putting Math.floor() and Math.random() together
--------------
El Nirvana está llegando, el portal místico espera
-----------
Genera números enteros aleatorios dentro de un rango
En lugar de generar un número entero aleatorio entre cero y un número dado como lo hicimos anteriormente, podemos generar un número entero aleatorio que se encuentre dentro de un rango de dos números específicos.

Para ello, definiremos un número mínimo min y un número máximo max.

Esta es la fórmula que utilizaremos. Tómate un momento para leerla e intenta entender lo que este código está haciendo:

Math.floor(Math.random() * (max - min + 1)) + min
Crea una función llamada randomRange que tenga un rango myMin y myMax y devuelva un número entero aleatorio mayor o igual a myMin, y es menor o igual a myMax, inclusivo.

-----------
function randomRange(myMin, myMax) {
  // Cambia solo el código debajo de esta línea
 return Math.floor(Math.random()*(myMax-myMin+1))+myMin
  //return 0;
  // Cambia solo el código encima de esta línea
}
-----------
¡Con el volumen a 11!
------------
Utiliza la función "parseInt"
La función parseInt() analiza una cadena y devuelve un entero. A continuación, te presentamos un ejemplo:

const a = parseInt("007");
La función anterior convierte la cadena 007 al entero 7. Si el primer carácter de la cadena no puede ser convertido en un número, entonces devuelve NaN.

Utiliza parseInt() en la función convertToInteger para convertir la cadena de entrada str a un número entero, y devuélvelo.
-----------

ADVERTISEMENT

freeCodeCamp Challenge Guide: Generate Random Whole Numbers with JavaScript
Guide

camperbot
Great contributor

5
Oct '19
Generate Random Whole Numbers with JavaScript 95
Solutions
Solution 1 (Click to Show/Hide)
var randomNumberBetween0and19 = Math.floor(Math.random() * 20);

function randomWholeNum() {
  // Only change code below this line.
  return Math.floor(Math.random() * 10);
}
Code Explanation
We need to use Math.floor() with Math.random() to generate and return a random whole number between 0 and 9.
Putting Math.floor() and Math.random() together
-------------

Problem Explanation
The parseInt() function will take any string parameter representing a number and return its integer value.

Hints
Hint 1
parseInt() should be used inside your function and return whatever str is, assuming that str is a string representing some number.

Solutions
Solution 1 (Click to Show/Hide)
function convertToInteger(str) {
  return parseInt(str);
}

convertToInteger("56");
------------
Eso no fue volar. Eso fue caer con estilo
------------
Utiliza la función "parseInt" con Radix (Base)
La función parseInt() analiza una cadena y devuelve un entero. Recibe un segundo argumento para la base (radix), que especifica la base del número representado en la cadena. La base (radix) puede ser un número entero entre 2 y 36.

La llamada a la función se realiza de la siguiente manera:

parseInt(string, radix);
Y aquí hay un ejemplo:

const a = parseInt("11", 2);
La variable radix indica que 11 está en el sistema binario, o base 2. Este ejemplo convierte la cadena 11 a un entero 3.

Utiliza parseInt() en la función convertToInteger para convertir un número binario en un número entero, y devolverlo.
----------
¡La cuchara no existe, Neo!
---------
Use the parseInt Function with a Radix 219
Hints
Hint 1
If you use a variable to assign the result of parseInt(str) to it, remember to return that variable.
Otherwise you can just use a return statement for your function.

Hint 2
In this exercise you need to “convert” a binary number into a decimal number using the radix parameter in order to specify the base on which the input number is represented on.

Solutions
Solution 1 (Click to Show/Hide)
function convertToInteger(str) {
  return parseInt(str, 2);
}
convertToInteger("10011");
Code Explanation
The function takes str and returns an integer instead of a string but “understanding” its a binary number instead of a decimal one thanks to the radix parameter (2).
Relevant Links
“parseInt()” - MDN JavaScript reference 439
“Radix” - Wikipedia 1.2k
---------------
Usa el operador condicional (ternario)
El operador condicional, también llamado el operador ternario, puede utilizarse como una expresión if-else de una sola línea.

La sintaxis es a ? b : c, donde a es la condición, b es el código a ejecutar cuando la condición devuelve true, y c es el código a ejecutar cuando la condición devuelve false.

La siguiente función utiliza una sentencia if/else para comprobar una condición:

function findGreater(a, b) {
  if(a > b) {
    return "a is greater";
  }
  else {
    return "b is greater or equal";
  }
}
Esto puede reescribirse usando el operador condicional:

function findGreater(a, b) {
  return a > b ? "a is greater" : "b is greater or equal";
}
Utiliza el operador condicional en la función checkEqual para comprobar si dos números son iguales o no. La función debe devolver la cadena Equal o la cadena Not Equal.
-----------
¡A buen paso dale prisa!
-----------
Usa el operador condicional (ternario)
El operador condicional, también llamado el operador ternario, puede utilizarse como una expresión if-else de una sola línea.

La sintaxis es a ? b : c, donde a es la condición, b es el código a ejecutar cuando la condición devuelve true, y c es el código a ejecutar cuando la condición devuelve false.

La siguiente función utiliza una sentencia if/else para comprobar una condición:

function findGreater(a, b) {
  if(a > b) {
    return "a is greater";
  }
  else {
    return "b is greater or equal";
  }
}
Esto puede reescribirse usando el operador condicional:

function findGreater(a, b) {
  return a > b ? "a is greater" : "b is greater or equal";
}
Utiliza el operador condicional en la función checkEqual para comprobar si dos números son iguales o no. La función debe devolver la cadena Equal o la cadena Not Equal.

-----------
usa múltiples operadores condicionales (ternarios)
En el desafío anterior, usaste un único operador condicional. También puedes encadenarlos para comprobar múltiples condiciones.

La siguiente función utiliza sentencias if, else if, y else para comprobar múltiples condiciones:

function findGreaterOrEqual(a, b) {
  if (a === b) {
    return "a and b are equal";
  }
  else if (a > b) {
    return "a is greater";
  }
  else {
    return "b is greater";
  }
}
La función anterior puede ser reescrita utilizando múltiples operadores condicionales:

function findGreaterOrEqual(a, b) {
  return (a === b) ? "a and b are equal" 
    : (a > b) ? "a is greater" 
    : "b is greater";
}
Se considera buena práctica dar formato a múltiples operadores condicionales de forma que cada condición esté en una línea separada, como se muestra arriba. Usar múltiples operadores condicionales sin una indentación adecuada puede hacer tu código difícil de leer. Por ejemplo:

function findGreaterOrEqual(a, b) {
  return (a === b) ? "a and b are equal" : (a > b) ? "a is greater" : "b is greater";
}
En la función checkSign, usa múltiples operadores condicionales (siguiendo el formato recomendado usado en findGreaterOrEqual) para comprobar si un número es positivo, negativo o cero. La función debe devolver positive, negative o zero.
----------
Use Multiple Conditional (Ternary) Operators 186
Solutions
Solution 1 (Click to Show/Hide)
function checkSign(num) {
  return num > 0 ? "positive"
    : num < 0 ? "negative"
    : "zero";
}
We need to use multiple conditional operators in the checkSign function to check if a number is positive, negative or zero.
------------
Thundercats, ¡guooooo!
-----------
Utiliza recursión para crear una cuenta regresiva
En un reto anterior, aprendiste a utilizar la recursividad para sustituir un bucle for. Ahora, echemos un vistazo a una función más compleja que devuelve un arreglo de enteros consecutivos empezando con 1 hasta el número pasado a la función.

Como se menciona en el desafío anterior, habrá un caso base. El caso base le dice a la función recursiva cuando no necesita llamarse a sí misma. Es un caso simple donde el valor de retorno ya se conoce. También habrá una llamada recursiva la cual ejecuta la función original con argumentos diferentes. Si la función se escribe correctamente, eventualmente el caso base será alcanzado.

Por ejemplo, digamos que quieres escribir una función recursiva que devuelva un arreglo conteniendo los números 1 hasta n. Esta función necesitará aceptar un argumento, n que representa el número final. Entonces necesitará llamarse a sí misma con valores progresivamente más pequeños de n hasta que alcance 1. Podrías escribir la función de la siguiente manera:

function countup(n) {
  if (n < 1) {
    return [];
  } else {
    const countArray = countup(n - 1);
    countArray.push(n);
    return countArray;
  }
}
console.log(countup(5));
El valor [1, 2, 3, 4, 5] se mostrará en la consola.

Al principio, esto parece contraintuitivo ya que el valor de n disminuye, pero los valores en el arreglo final se están incrementando. Esto sucede porque la inserción ocurre al último, después de la llamada recursiva. En el punto donde n es empujado en el arreglo, countup(n - 1) ya ha sido evaluada y devuelto [1, 2, ..., n - 1].

Hemos definido una función llamada countdown con un parámetro (n). La función debe usar recursión para devolver un arreglo conteniendo los n enteros hasta 1 basado en el parámetro n. Si la función es llamada con un número menor a 1, la función debe devolver un arreglo vacío. Por ejemplo, llamar esta función con n = 5 debe devolver el arreglo [5, 4, 3, 2, 1]. Tu función debe usar recursión llamándose a sí misma y no debe usar bucles de ningún tipo.
------------


6
Dec '19
Use Recursion to Create a Countdown 1.6k
Solutions
Solution 1 (Click to Show/Hide)
function countdown(n) {
  if (n < 1) {
    return [];
  } else {
    const arr = countdown(n - 1);
    arr.unshift(n);
    return arr;
  }
}
Solution 2 (Click to Show/Hide)
function countdown(n) {
  if (n < 1) {
    return [];
  } else {
    const arr = countdown(n - 1);
    arr.splice(0, 0, n);
    return arr;
  }
}
Solution 3 (Click to Show/Hide)
function countdown(n){
   return n < 1 ? [] : [n].concat(countdown(n - 1));
}
Solution 4 (Click to Show/Hide)
function countdown(n){
   return n < 1 ? [] : [n, ...countdown(n - 1)];
}
heart
clap
open_mouth
164



created
Aug '19
last reply
Jun '21
2
replies
249k
views
2
users
352
likes
19
links

9 MONTHS LATER

snigo

2
May '20
Guide to understanding recursion
As it’s one of the most frequently asked questions on the forum I’ve decided to answer here, so all of you who have hard times with recursion can easily find it.

Part 1. Precedence
First step to understand recursion requires understanding of operator precedence in JavaScript:

Operator precedence determines how operators are parsed concerning each other. Operators with higher precedence become the operands of operators with lower precedence.

Source: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Operator_Precedence 1.5k

What it’s saying is if you have this code:


const a = 42 + someFunction() / 2;

JS parser will have to have certain rules of what to evaluate first. Let’s check precedence table from the link above and parse this statement:

20: Function Call
Call someFunction() and substitute the return value
*(let’s say someFunction() returns 100):

const a = 42 + 100 / 2;

15: Division
as we know from the school division will go before the addition

const a = 42 + 50;

14: Addition

const a = 92;

3: Assignment
at this point parser will assign 92 to a constant variable a;

You might ask what does precedence have to do with the recursion? Everything! It is a direct side effect of precedence:


function recurseForever(a) {
  return recurseForever(a + 1);
}

Outer function recurseForever will return NOT the inner function, BUT the result of it! There is no special logic or mode in the language that allows recursion, no! It’s simply an order in which things get evaluated by parser.

Part 2. Stack
If you try to run recurseForever function from the example above, of course, it won’t run forever, in fact it would very quickly throw an error:


Uncaught RangeError: Maximum call stack size exceeded

Whenever you see something like this, it means it’s time to debug! And the first step of any debugging is to understand a context of an Error. After reading about RangeError 265 and Call Stack 273 we’re coming to conclusion that we have this internal structure called “Call Stack” with some limited size (Range) and whenever we exceed the size we will get this RangeError, good!

Now when we know the context of a problem (“WHAT”), it’s time to search for a reason (“WHY”). Whenever a JavaScript engine runs a function it pushes it to the Call Stack. Think of Call Stack as an primitive array with just a two methods:

push(fn) - pushes function to the stack. Invoked whenever it sees the function call

pop() - removes the last function from the stack. Invoked whenever the last statement of the current function is executed. Let’s simulate that with pseudo-function parseLine:


const callStack = [];

parseLine('recurseForever(0);'); // Oh, it's a function call!
callStack.push(recurseForever);

parseLine('return recurseForever(a + 1);');

/**
 * Ok, as we already know from Precedence part,
 * the first thing we will deal with here is recurseForever(a + 1)
 * which is another function call!
 */
callStack.push(recurseForever);

parseLine('return recurseForever(a + 1);');

/**
 * And here's the BUG!
 * Have you noticed it?
 */

We went back to the exact same argument and without simulating further it must be clearly understandable that we will keep pushing our function to the call stack until it’s size is exceeded.

Now, let’s fix it!

Part 3. Iteration
Before we fix our recursive function though, let’s quickly consider one quick thing first, because when I said this just now:

We went back to the exact same argument

I actually lied! :pleading_face:

In every function call we indeed have new arguments. We started with 0, then inside the function body we called our function with a + 1, so 1, then 2, 3 … and so on. To verify that let’s log an argument:


function recurseForever(a) {
  console.log(a);
  return recurseForever(a + 1);
}

recurseForever(0);

// Ok, now we know the size of a call stack

And NOW pattern recognition abilities of your brain must start ringing bells: “Wait a minute - this looks just like a loop! We’re simply iterating!”. And you’re right (even if that was just my bells). We can very easily “convert” our function to a loop:


// Don't run this
function recurseReallyForever(a) {
  while ("We can") {
    a += 1;
  }

  return a;
}

The only exception here is that our call stack in the case of recurseReallyForever(a) will not be exceeded - it only will have one outer function, because there are no function calls inside. Instead there is a while loop inside that now will truly run forever and crush our browser.

And this is a point of midway takeaways!

Takeaway 1:
Whenever you “attach” parentheses to a function name it’s no longer a function, but a result of the function:


function fortyTwo() {
  return 42;
}

typeof fortyTwo; // "function"
typeof fortyTwo(); // "number"

Takeaway 2:
Recursion is nothing else than iteration that doesn’t use iterable data structures (like array), but instead uses an array-like system structure called Call Stack. The natural function of recursion is to repeat itself over some set of changing arguments.

Part 4. Base case
Now finally, with all the knowledge we’ve just read, let’s fix our bug! In order to do that, in some point of the iterations of our initial recurseForever function we need a condition in which we no longer make a function call - an exit contract. We call such a condition “Base case”. Every recursive function has to have one, otherwise it will cause a problem and as general convention we normally put base case as a first thing in the recursive function:


function recurseForever(a) {
  // base case
  if (a >= 10) return a;

  console.log(a);
  
  return recurseForever(a + 1);
}

Congratulations! Base case isn’t exclusively a part of recursive function, it is as well a part of any iteration - exit condition out of iteration and you use it all the time with loops etc.

Part 5. Result
If you run the final version of our function recurseForever(0) you will get what seems like logs from 0 to 10 and the first naive guess that they came from console.log(a) method, right? But why was 10 logged? Number 10 satisfies our base case and therefore console.log(a) with a = 10 never was invoked, instead 10 is a result of our function that was sent to stdout because we haven’t instructed to assign this value to anything and that’s a default behaviour. Compare outputs:


recurseForever(0); // logs 0 ... 10

const result = recurseForever(0); // logs 0 ... 9
console.log(result); // And that's where 10 did go!

And now I need maximum focus! Because it’s the core of all the confusion.

"How the hell result equals 10?!!"

Magic, ha! There are two ways to understand what has just happened:

Logical

Technical

Logical
I call this a “logical traversal of recursive call”, though it’s not an official or conventional term. The key is to start from the end and iterate backwards. What’s the (successful) end of any recursion? Base case!


// What's the output of the following?

recurseForever(10);

// Easy - 10!

Now iterating backwards:


// What's the output of the following?

recurseForever(9);

// We're skipping base case
// and returning recurseForever(9 + 1);

Now taking into consideration the takeaway 1 from the above, what’s recurseForever(9 + 1)? It’s no longer a function, it’s a value - 10!
Now continue the same process:


// What's the output of the following?

recurseForever(8);

// recurseForever(8 + 1), which we've just calculated

…and let’s stop here actually. We clearly see a recurring pattern here that kinda suggests following:

"If we can get the next recursive iteration after the base case to work, then our recursive function works!"

So coming back to the countdown() function from the thread, our base case would be 1 because it’s 100% clear how to make a countdown from 1, right?


countdown(1);
/* this shall immediately return [1] without recursion */

Now all we need to do is to take the next after the base case input - 2 and produce [2, 1] output in a recursive way and that would guarantee the rest of the cases! Pretty neat! We’ll get back to this!

Technical
To understand how exactly this works under the hood we need to get back to the Call Stack. As we’ve seen any recursion is a process of inflating the stack, until we either hit the limit of the stack or the base case occurs. After the case of the latter we will initiate a backward process of deflating the stack, as our imaginary parseLine function will move to the next line, ending each function and popping it out of stack in reverse order.

Reverse is a key word here and is a result of the nature of the Stack. Imagine a stack of cards: inflating the stack would mean taking cards and stack them on top of each other one by one: push(). Deflating stack would mean taking cards out of the stack from the top until you reach the bottom: pop(). So Last card pushed In would be the First card taken Out (LIFO). The graphical chart where x is time and y is a stack size would look like this:


      * <- base case
     ***
    *****
   *******
  *********
 ***********
************* <- result

Every row of this graph is a separate instance of our function. We’ve called only one of them - the one at the bottom, the rest were called subsequently in the process of inflation. Each of these functions carries its own result and passes it down until it reaches our main function at the bottom. Here is the same in the form of timeline:


STEP 1: recurseForever(0) pushed to Call Stack
STEP 2: recurseForever(1) pushed to Call Stack

...

STEP 10: recurseForever(9) pushed to Call Stack
STEP 11: recurseForever(10) pushed to Call Stack
STEP 12: recurseForever(10) popped out of Call Stack carrying 10
STEP 13: recurseForever(9) popped out of Call Stack carrying 10
STEP 14: recurseForever(8) popped out of Call Stack carrying 10

...

STEP 21: recurseForever(1) popped out of Call Stack carrying 10
STEP 22: recurseForever(0) popped out of Call Stack carrying 10
STACK EMPTY

As you can see after our function is getting popped out of the call stack it carries value (we also say “it’s evaluated to”) that now can be assigned, returned or simply printed to stdout by JavaScript engine.

Here is another visualisation of similar process kindly made by @ilenia:
Untitled Diagram (1)
Untitled Diagram (1)
1460×575 40.1 KB

Red line on this diagram represent inflation of the call stack and blue line - deflation that carries the output towards the the initial function call.
Part 6. Solution
The best way to understand how the solution works is to solve it :slight_smile:

 Step 1 (click to show/hide)
So what’s our input, what do we know? We know that countdown expects number n and has to output an array from n to 1. Right away it’s sufficient for us to write couple lines of code:


function countdown(n) {
  // base case
  if (n === 1) return [1];

  // in some point we need to iterate towards base case
  countdown(n - 1);
}

 Step 2 (click to show/hide)
Now, what’s the next step after the base case? Number 2. Given input where n = 2 we need to produce the following output: [2, 1]. Any ideas? We know that countdown(n - 1) will return [1]. How do we get from [1] to [2, 1]? Well, that’s not hard!


function countdown(n) {
  // base case
  if (n === 1) return [1];

  const output = [n]; // [2]
  return output.concat(countdown(n - 1)); // [2, 1]
}

Ok, one can say “You’ve hardcoded it with n = 2, cheater!”. What do you think, are we hardcoders? :wink: Let’s test it:


countdown(5); // [5, 4, 3, 2, 1]
countdown(7); // [7, 6, 5, 4, 3, 2, 1]

Works!!! :sunglasses:

 Step 3 (click to show/hide)
Now the challenge has additional requirement: if n less than 1 we shall return an empty array. Let’s add this:


function countdown(n) {
  // base case
  if (n < 1) return [];
  if (n === 1) return [1];
  
  const output = [n]; // [2]
  return output.concat(countdown(n - 1)); // [2, 1]
}

Then test again:


countdown(0); // []
countdown(-33); // []

Yei!

Now let’s refactor a bit. I think we have couple unnecessary lines:


function countdown(n) {
  // base case
  if (n < 1) return [];
  if (n === 1) return [1]; // Do we really need this line?

  /**
   * To check it all we need is just to simulate all the above
   * for input 0 as base case and 1 as a next
   * so the return value for n = 1 would be [1].concat([]);
   */

  const output = [n]; // Notice how we assign this to output just to return it on the next line. Waste of line!
  return output.concat(countdown(n - 1));
}

 Solution (click to show/hide)
And here is the result:

function countdown(n) {
  if (n < 1) return [];

  return [n].concat(countdown(n - 1));
}

// or using ternary operator

function countdown(n) {
  return (n < 1) ? [] : [n].concat(countdown(n - 1));
}

Boom!

Part 7. Couple extra famous examples
Factorial (easy)

function factorial(n) {}

STEP 1: What’s factorial? It’s 1 * 2 * 3 * … * n.

STEP 2: Base case and iteration? Looking at the above, if we have n then we go to 1: (n - 1) until n === 1

STEP 3: Write it:


function factorial(n) {
  // considering the fact that 1 * n = n
  if (n === 1) return n;

  return factorial(n - 1);
}

STEP 4: Produce the next result after base case: factorial(2) -> 2. How to return 2 if we have 1?

STEP 5: Back to code:


function factorial(n) {
  if (n === 1) return n;
  
  return n * factorial(n - 1); // 2 * 1 - just what we need
}

STEP 6: Test other numbers


factorial(4); // 24 Correct!
factorial(5); // 120 Correct!

Tree traversal (intermediate)
This example is intentionally different to show you other applications of recursive function. Probably the most famous of which is tree traversal.


/**
 * Traverses tree from starting node
 * until it finds node with given id
 * if not found returns null
 */

function getElementById(node, id) {}

Iteration here is a bit different because every node has child nodes under node.children property, so we need to check all the children and children of those children and so on until either we’ve checked all nodes or found the one we’re looking for. And that would be our base cases:


function getElementById(node, id) {
  /* base case # 1 */
  if (node.id === id) return node;

  /* if not, iterate over each child node repeating the process */
  for (const child of node.children) {

    /* repeat the same function for child and its children */
    const match = getElementById(child, id);

    /* if match gave us result - return it immediately */
    if (match) return match;

    /* if not, continue loop */
    /* we cannot return null without checking all children first */
  }

  /* if loop finishes and we haven't matched node at this point then it's base case #2 */
  return null;
}

Part 8. Conclusion
Ok, here are key takeaways:

Understanding recursion requires understanding of many programming principles and that’s why it might be overwhelming sometimes. Just look at the length of this guide.

Recursion often compared against iteration, but in a nutshell it’s also an iteration (otherwise they would simply be incomparable)

Each iteration of recursive function requires new arguments and the change between previous and the next argument has to point towards the base case

Recursion has very solid structure that is divided in two parts: inflation - all the code before internal function call and deflation - all the code that will run “on the way back”. Understanding and seeing this abstract structures gives you more understanding when you read or compose recursive function.

Good luck!
----------------
¡No contaban con tu astucia!
---------------
Usa recursión para crear un rango de números
Continuando con el desafío anterior, te ofrecemos otra oportunidad de crear una función recursiva para resolver un problema.

Hemos definido una función llamada rangeOfNumbers con dos parámetros. La función debe devolver un arreglo de enteros que comienza con el número representado por el parámetro startNum y termina con el número representado por el parámetro endNum. El número inicial será siempre menor o igual que el número final. Tu función debe utilizar recursión, llamándose a sí misma, y no utilizar bucles de ningún tipo. También debe funcionar en el caso que startNum y endNum sean iguales.

freeCodeCamp Challenge Guide: Use Recursion to Create a Range of Numbers
Guide

camperbot
Great contributor

6
Aug 17
Use Recursion to Create a Range of Numbers 2.6k
Solutions
 Solution 1 (Click to Show/Hide)
function rangeOfNumbers(startNum, endNum) {
  if (endNum < startNum) {
    return [];
  } else {
    const numbers = rangeOfNumbers(startNum, endNum - 1);
    numbers.push(endNum);
    return numbers;
  }
}
 Solution 2 (Click to Show/Hide)
function rangeOfNumbers(startNum, endNum) {
  return endNum < startNum
    ? []
    : rangeOfNumbers(startNum, endNum - 1).concat(endNum);
}
 Solution 3 (Click to Show/Hide)
function rangeOfNumbers(startNum, endNum) {
  return endNum < startNum
    ? []
    : [...rangeOfNumbers(startNum, endNum - 1), endNum];
}
-------------------------
¡Estás en llamas!
---------
Compara el alcance de las palabras clave "var" y "let"
Si no estás familiarizado con let, verifica este desafío sobre la diferencia entre let y var.

Cuando declaras una variable con la palabra clave var, esta es declarada globalmente o localmente sí es declarada dentro de una función.

La palabra clave let se comporta de forma similar, pero con algunas características adicionales. Cuanto declaras una variable con la palabra clave let dentro de un bloque, una declaración o expresión. Su alcance está limitado a ese bloque, declaración o expresión.

Por ejemplo:

var numArray = [];
for (var i = 0; i < 3; i++) {
  numArray.push(i);
}
console.log(numArray);
console.log(i);
Aquí la consola mostrará los valores [0, 1, 2] y 3.

Con la palabra clave var, i es declarada globalmente. Así, cuando i++ es ejecutado, la variable global es actualizada. Este código es similar al siguiente:

var numArray = [];
var i;
for (i = 0; i < 3; i++) {
  numArray.push(i);
}
console.log(numArray);
console.log(i);
Aquí la consola mostrará los valores [0, 1, 2] y 3.

Este comportamiento causará problemas si creas una función y la almacenas para su uso posterior dentro de un bucle for que usa la variable i. Esto se debe a que la función almacenada siempre se referirá al valor de la variable global i actualizada.

var printNumTwo;
for (var i = 0; i < 3; i++) {
  if (i === 2) {
    printNumTwo = function() {
      return i;
    };
  }
}
console.log(printNumTwo());
Aquí la consola mostrará el valor 3.

Como puedes ver, printNumTwo() imprime 3 y no 2. Esto es porque el valor asignado a i fue actualizado y la función printNumTwo() devuelve el global de i y no el valor que tenía i cuando la función fue creada en el bucle for. La palabra clave let no sigue este comportamiento:

let printNumTwo;
for (let i = 0; i < 3; i++) {
  if (i === 2) {
    printNumTwo = function() {
      return i;
    };
  }
}
console.log(printNumTwo());
console.log(i);
Aquí la consola mostrará el valor 2 y el error que i is not defined.

i no está definida, porque no ha sido declarada en el ámbito global. Solo ha sido declarada dentro de la sentencia de bucle for. printNumTwo() devolvió el valor correcto, porque tres variables diferentes de i con valores únicos (0, 1 y 2) fueron creadas por la palabra clave let dentro de la sentencia del bucle.

Corrige el código para que la variable i, declarada en la sentencia if sea una variable separada de la variable i, declarada en la primera línea de la función. Asegúrate de no utilizar la palabra clave var en ninguna parte de tu código.

Este ejercicio está diseñado para ilustrar la diferencia entre como las palabras claves var y let asignan ámbito a la variable declarada. Cuando programas una función similar a la que es usada en este ejercicio, es a menudo mejor usar diferentes nombres de variables para evitar confusión.
----------
ES6
ECMAScript, o ES, es una versión estandarizada de JavaScript. Debido a que todos los principales navegadores siguen esta especificación, los términos ECMAScript y JavaScript son intercambiables.

La mayoría del JavaScript que has aprendido hasta este punto estaba en ES5 (ECMAScript 5), el cual fue finalizado en 2009. Aunque puedes seguir escribiendo programas en ES5, JavaScript está evolucionando siempre, y cada año se lanzan nuevas funcionalidades.

ES6, lanzado en 2015, agrego muchas nuevas y potentes características al lenguaje. En este curso, aprenderás estas nuevas características, incluyendo let y const, funciones flecha, clases, promesas, y módulos.


Contraer cursoES6
0/29, 0 de 29 desafíos completados
Sin aprobar
Compara el alcance de las palabras clave "var" y "let"
Sin aprobar
Muta un arreglo declarado con const
Sin aprobar
Prevenir la mutación del objeto
Sin aprobar
Usa funciones flecha para escribir funciones anónimas de manera breve
Sin aprobar
Escribe funciones flecha con parámetros
Sin aprobar
Establece parámetros por defecto para tus funciones
Sin aprobar
Utiliza el parámetro rest con parámetros de función
Sin aprobar
Utiliza el operador de propagación para evaluar los arreglos en el lugar
Sin aprobar
Usa sintaxis de desestructuración para extraer valores de objetos
Sin aprobar
Usa sintaxis de desestructuración para asignar variables desde objetos
Sin aprobar
Usa sintaxis de desestructuración para asignar variables desde objetos anidados
Sin aprobar
Usa sintaxis de desestructuración para asignar variables desde arreglos
Sin aprobar
Utiliza la sintaxis de desestructuración con el parámetro rest para reasignar elementos de un arreglo
Sin aprobar
Utiliza sintaxis de desestructuración para pasar un objeto como parámetro de función
Sin aprobar
Crea cadenas usando plantillas literales
Sin aprobar
Escribe declaraciones concisas de objecto literales usando la abreviatura de propiedad de objeto
Sin aprobar
Escribe funciones breves y declarativas con ES6
Sin aprobar
Usa sintaxis de clases para definir una función constructora
Sin aprobar
Utiliza getters (accesores) y setters (mutadores) para controlar el acceso a un objeto
Sin aprobar
Crea un módulo para scripts
Sin aprobar
Utiliza la exportación para compartir un bloque de código
Sin aprobar
Reutiliza código de JavaScript utilizando import
Sin aprobar
Use * para importar todo de un archivo
Sin aprobar
Crear un fallback de exportación con export default
Sin aprobar
Importa una exportación por defecto
Sin aprobar
Crea una promesa de JavaScript
Sin aprobar
Cumpleta una promesa con "resolve" y "reject"
Sin aprobar
Maneja una promesa cumplida usando then
Sin aprobar
Maneja una promesa rechazada usando catch
---------------------
Compara el alcance de las palabras clave "var" y "let"
Si no estás familiarizado con let, verifica este desafío sobre la diferencia entre let y var.

Cuando declaras una variable con la palabra clave var, esta es declarada globalmente o localmente sí es declarada dentro de una función.

La palabra clave let se comporta de forma similar, pero con algunas características adicionales. Cuanto declaras una variable con la palabra clave let dentro de un bloque, una declaración o expresión. Su alcance está limitado a ese bloque, declaración o expresión.

Por ejemplo:

var numArray = [];
for (var i = 0; i < 3; i++) {
  numArray.push(i);
}
console.log(numArray);
console.log(i);
Aquí la consola mostrará los valores [0, 1, 2] y 3.

Con la palabra clave var, i es declarada globalmente. Así, cuando i++ es ejecutado, la variable global es actualizada. Este código es similar al siguiente:

var numArray = [];
var i;
for (i = 0; i < 3; i++) {
  numArray.push(i);
}
console.log(numArray);
console.log(i);
Aquí la consola mostrará los valores [0, 1, 2] y 3.

Este comportamiento causará problemas si creas una función y la almacenas para su uso posterior dentro de un bucle for que usa la variable i. Esto se debe a que la función almacenada siempre se referirá al valor de la variable global i actualizada.

var printNumTwo;
for (var i = 0; i < 3; i++) {
  if (i === 2) {
    printNumTwo = function() {
      return i;
    };
  }
}
console.log(printNumTwo());
Aquí la consola mostrará el valor 3.

Como puedes ver, printNumTwo() imprime 3 y no 2. Esto es porque el valor asignado a i fue actualizado y la función printNumTwo() devuelve el global de i y no el valor que tenía i cuando la función fue creada en el bucle for. La palabra clave let no sigue este comportamiento:

let printNumTwo;
for (let i = 0; i < 3; i++) {
  if (i === 2) {
    printNumTwo = function() {
      return i;
    };
  }
}
console.log(printNumTwo());
console.log(i);
Aquí la consola mostrará el valor 2 y el error que i is not defined.

i no está definida, porque no ha sido declarada en el ámbito global. Solo ha sido declarada dentro de la sentencia de bucle for. printNumTwo() devolvió el valor correcto, porque tres variables diferentes de i con valores únicos (0, 1 y 2) fueron creadas por la palabra clave let dentro de la sentencia del bucle.

Corrige el código para que la variable i, declarada en la sentencia if sea una variable separada de la variable i, declarada en la primera línea de la función. Asegúrate de no utilizar la palabra clave var en ninguna parte de tu código.

Este ejercicio está diseñado para ilustrar la diferencia entre como las palabras claves var y let asignan ámbito a la variable declarada. Cuando programas una función similar a la que es usada en este ejercicio, es a menudo mejor usar diferentes nombres de variables para evitar confusión.
------------
freeCodeCamp Challenge Guide: Compare Scopes of the var and let Keywords
Guide

camperbot
Great contributor

1
Oct '19
Compare Scopes of the var and let Keywords 454
Problem Explanation
Change the code so that the variable i declared in the if block is separately scoped than the variable i declared at the beginning of the function.

Hints
Hint 1
Be certain not to use the var keyword anywhere in your code.
Hint 2
Remember that let's scope is limited to the block, function or statement in which you declare it.
Solutions
Solution 1 (Click to Show/Hide)
function checkScope() {
  "use strict";
  let i = "function scope";
  if (true) {
    let i = "block scope";
    console.log("Block scope i is: ", i);
  }
  console.log("Function scope i is: ", i);
  return i;
}
Code Explanation
By using let you can declare variables in relation to their scope.
-------------
¡Más rápido que la vista!
------------
function checkScope() {
  
  let i = 'function scope';
  if (true) {
   let i = 'block scope';
    console.log('Block scope i is: ', i);
  }
  console.log('Function scope i is: ', i);
  return i;
}
--------------
Muta un arreglo declarado con const
Si no estás familiarizada con const, verifica este desafío sobre la palabra clave const.

La declaración const tiene muchos casos de uso, en el JavaScript moderno.

Algunos desarrolladores prefieren asignar todas sus variables utilizando const por defecto, a menos que sepan que necesitarán reasignar el valor. Solo en ese caso, utilizan let.

Sin embargo, es importante comprender que los objetos (incluyendo arreglos y funciones), asignados a una variable usando const siguen siendo mutables. Usar la declaración const solo previene la reasignación del identificador de una variable.

const s = [5, 6, 7];
s = [1, 2, 3];
s[2] = 45;
console.log(s);
s = [1, 2, 3] resultará en un error. Después de comentar esa línea, el console.log mostrará el valor [5, 6, 45].

Como puedes ver, puedes mutar el objeto [5, 6, 7] en sí mismo y la variable s seguirá apuntado al arreglo alterado [5, 6, 45]. Como todos los arreglos, los elementos del arreglo en s son mutables, pero debido a que se utilizó const, no puedes utilizar el identificador de la variable s para apuntar a un arreglo diferente usando el operador de asignación.

Un arreglo es declarado como const s = [5, 7, 2]. Cambia el arreglo a [2, 5, 7] utilizando varias asignaciones de elementos.

-----------------------
¡Triunfo superlativo!
----------------
Prevenir la mutación del objeto
Como se vio en el desafío anterior, la declaración const por sí sola no protege la información de la mutación. Para asegurar que tu información no cambie, JavaScript provee una función Object.freeze para prevenir la mutación de datos.

Cualquier intento de cambiar el objeto será rechazado, lanzando un error si el script se ejecuta en modo estricto (strict mode).

let obj = {
  name:"FreeCodeCamp",
  review:"Awesome"
};
Object.freeze(obj);
obj.review = "bad";
obj.newProp = "Test";
console.log(obj); 
Las asignaciones obj.review y obj.newProp provocarán errores, porque nuestro editor se ejecuta en modo estricto por defecto, y la consola mostrará el valor { name: "FreeCodeCamp", review: "Awesome" }.

En este desafío vas a utilizar Object.freeze para prevenir el cambio de constantes matemáticas. Necesitas congelar el objeto MATH_CONSTANTS para que nadie pueda alterar el valor de PI, añadir o borrar propiedades.
----------
¡Tienes agallas!
----------
Usa funciones flecha para escribir funciones anónimas de manera breve
En JavaScript, usualmente no necesitas nombrar tus funciones, especialmente cuando se pasa una función como argumento a otra función. En su lugar, creamos funciones inline (en línea). No necesitamos nombrar estas funciones porque no las reutilizamos en otro lugar.

Para lograr esto, por lo general se usa la siguiente sintaxis:

const myFunc = function() {
  const myVar = "value";
  return myVar;
}
ES6 nos proporciona el azúcar sintáctico, para no tener que escribir funciones anónimas de este modo. En su lugar, puedes usar la sintaxis de función flecha:

const myFunc = () => {
  const myVar = "value";
  return myVar;
}
Cuando la función no posee cuerpo y sólo tiene un valor de retorno, la sintaxis de "función de flecha", te permite omitir la palabra clave return, así como los corchetes que rodean el código. Esto ayuda a simplificar las funciones más pequeñas en sentencias de una sola línea:

const myFunc = () => "value";
Este código todavía devolverá la cadena value por defecto.

Reescribe la función asignada a la variable magic, la cual devuelve una new Date(), utilizando la sintaxis de función flecha. Además, asegúrate de que nada esté definido usando la palabra clave var.
-----------------
Guía del desafío freeCodeCamp: use funciones de flecha para escribir funciones anónimas concisas
Guía

autocaravana
Gran colaborador

2
Aug '21
Use funciones de flecha para escribir funciones anónimas concisas 288
Problema Explicación
Una vez más, ES6 se trata de hacer que JavaScript sea más elegante y, para algunos, más legible.

Las funciones anónimas, como se indicó, se pueden crear cuando está seguro de que la función no se llamará por su nombre en ningún otro lugar.

Sugerencias
Pista 1
Deshazte de la functionpalabra clave y conecta esta =>flecha.

Pista 2
¿Te deshiciste de la varpalabra clave?

Soluciones
Solución 1 (haga clic para mostrar/ocultar)
const magic = () => {
  return new Date();
};
Mientras te deshagas de la varpalabra clave, estás bien.

Solución 2 (haga clic para mostrar/ocultar)
const magic = () => new Date();
Función de flecha de una sola línea con retorno implícito.
-------------
Thundercats, ¡guooooo!
----------------
Escribe funciones flecha con parámetros
Al igual que una función regular, puedes pasar argumentos a una función flecha.

const doubler = (item) => item * 2;
doubler(4);
doubler(4) devolvería el valor 8.

Si una función flecha tiene un solo parámetro, los paréntesis que encierran el parámetro pueden ser omitidos.

const doubler = item => item * 2;
Es posible pasar más de un argumento a una función flecha.

const multiplier = (item, multi) => item * multi;
multiplier(4, 2);
multiplier(4, 2) devolverá el valor 8.

Reescribe la función myConcat que añade el contenido de arr2 a arr1 para que la función use la sintaxis de función flecha.
------------
Guía del desafío freeCodeCamp: Escribir funciones de flecha con parámetros
Guía

autocaravana
Gran colaborador

2
mar '20
Escribir funciones de flecha con parámetros 165
Problema Explicación
Ahora, tiene la tarea de colocar parámetros dentro de funciones de flecha.

Sugerencias
Pista 1
Deshazte de la functionpalabra clave. Poner el operador de flecha.

Pista 2
Asegúrate de haber cambiado el vara un const.

Soluciones
Solución 1 (haga clic para mostrar/ocultar)
const myConcat = (arr1, arr2) => {
  "use strict";
  return arr1.concat(arr2);
};
// test your code
console.log(myConcat([1, 2], [3, 4, 5]));
-------------

const myConcat=(arr1,arr2) =>{
  return arr1.concat(arr2)}

console.log(myConcat([1,2],[3,4,5,]))
-----------
¡Estás en llamas!
------------
Establece parámetros por defecto para tus funciones
Para ayudarnos a crear funciones más flexibles, ES6 introduce parametros por defecto para funciones.

Echa un vistazo, al siguente código:

const greeting = (name = "Anonymous") => "Hello " + name;

console.log(greeting("John"));
console.log(greeting());
La consola mostrará las cadenas Hello John y Hello Anonymous.

El parámetro por defecto entra en juego cuando el argumento no es especificado (es indefinido). Como puedes ver en el ejemplo anterior, el parámetro name recibirá su valor por defecto Anonymous cuando no proveas un valor para el parámetro. Puede agregar valores por defecto para tantos parámetros como desees.

Modifica la función increment agregando parámetros por defecto para que sume 1 a number si value no se especifica.
--------------
Establece parámetros por defecto para tus funciones
Para ayudarnos a crear funciones más flexibles, ES6 introduce parametros por defecto para funciones.

Echa un vistazo, al siguente código:

const greeting = (name = "Anonymous") => "Hello " + name;

console.log(greeting("John"));
console.log(greeting());
La consola mostrará las cadenas Hello John y Hello Anonymous.

El parámetro por defecto entra en juego cuando el argumento no es especificado (es indefinido). Como puedes ver en el ejemplo anterior, el parámetro name recibirá su valor por defecto Anonymous cuando no proveas un valor para el parámetro. Puede agregar valores por defecto para tantos parámetros como desees.

Modifica la función increment agregando parámetros por defecto para que sume 1 a number si value no se especifica.
------------
const increment = (number, value=1) => number + value;
console.log(increment());
console.log(increment(5))
------------
¡Súper combo!
------------
Utiliza el parámetro rest con parámetros de función
Para ayudarnos a crear funciones más flexibles, ES6 introduce el parámetro rest para los parámetros de función. Con el parámetro rest, puedes crear funciones que tomen un número variable de argumentos. Estos argumentos se almacenan en un arreglo al que se puede acceder más tarde desde dentro de la función.

Echa un vistazo a este código:

function howMany(...args) {
  return "You have passed " + args.length + " arguments.";
}
console.log(howMany(0, 1, 2));
console.log(howMany("string", null, [1, 2, 3], { }));
La consola mostrará las cadenas You have passed 3 arguments. y You have passed 4 arguments..

El parámetro rest elimina la necesidad de comprobar el arreglo args y nos permite aplicar map(), filter() y reduce() en el arreglo de parámetros.

Modifica la función sum usando el parámetro rest de tal manera que la función sum sea capaz de recibir cualquier número de argumentos y devolver su suma
-------------

Guía del desafío freeCodeCamp: Escribir funciones de flecha con parámetros
Guía

autocaravana
Gran colaborador

2
Mar '20
Escribir funciones de flecha con parámetros 165
Problema Explicación
Ahora, tiene la tarea de colocar parámetros dentro de funciones de flecha.

Sugerencias
Pista 1
Deshazte de la functionpalabra clave. Poner el operador de flecha.

Pista 2
Asegúrate de haber cambiado el vara un const.

Soluciones
Solución 1 (haga clic para mostrar/ocultar)
const myConcat = (arr1, arr2) => {
  "use strict";
  return arr1.concat(arr2);
};
// test your code
console.log(myConcat([1, 2], [3, 4, 5]));
----------------
const sum = (...args) => {
  return args.reduce((a, b) => a + b, 0);
}
console.log(sum(1,2,0));
------------------
¿Nivel de poder? ¡Supera los 9000!
-----------------
Utiliza el operador de propagación para evaluar los arreglos en el lugar
ES6 introduce el operador de propagación, que nos permite expandir arreglos y otras expresiones en lugares donde se esperan múltiples parámetros o elementos.

El siguiente código ES5 usa apply() para calcular el valor máximo en un arreglo:

var arr = [6, 89, 3, 45];
var maximus = Math.max.apply(null, arr);
maximus tendrá un valor de 89.

Tuvimos que usar Math.max.apply(null, arr) porque Math.max(arr) devuelve NaN. Math.max() espera argumentos separados por comas, pero no un arreglo. El operador de propagación hace que esta sintaxis sea más fácil de leer y mantener.

const arr = [6, 89, 3, 45];
const maximus = Math.max(...arr);
maximus tendría un valor de 89.

...arr devuelve un arreglo desempacado. En otras palabras, propaga el arreglo. Sin embargo, el operador de propagación sólo funciona en el lugar, como en un argumento de función o en un arreglo literal. El siguiente código no funcionará:

const spreaded = ...arr;
Copia todo el contenido de arr1 en otro arreglo arr2 usando el operador de propagación.
--------------
¡Eres más fuerte de lo que crees
--------------
let numbers = [-12, 160, 0, -3, 51];
let minNum = Math.min.apply(null, numbers);
console.log(minNum); //-12
let numbers = [-12, 160, 0, -3, 51];
let minNum = Math.min(numbers);
console.log(minNum); //NaN
let numbers = [-12, 160, 0, -3, 51];
let minNum = Math.min(...numbers);
console.log(minNum); //-12
Solutions
const arr1 = ['JAN', 'FEB', 'MAR', 'APR', 'MAY'];
let arr2 

arr2 = [...arr1];  // Change this line

console.log(arr2);
Code Explanation
Unpacking the arr1 using the spread operator and then copying those values to arr2
--------------
Usa sintaxis de desestructuración para extraer valores de objetos
La sintaxis de desestructuración es una sintaxis especial introducida en ES6, para asignar los valores directamente desde un objeto.

Considera el siguiente código ES5:

const user = { name: 'John Doe', age: 34 };

const name = user.name;
const age = user.age;
name tendría una cadena con valor John Doe, y age tendría el número 34.

Aquí hay una sentencia de asignación equivalente usando la sintaxis de desestructuración de ES6:

const { name, age } = user;
De nuevo, name tendrá una cadena con valor John Doe, y age tendrá el número 34.

Aquí, las variables name y age serán creadas y se asignarán los valores respectivos a partir del objeto user. Puedes observar que esto es mucho más limpio.

Puedes extraer tantos o pocos valores del objeto como desees.

Reemplaza las dos asignaciones con una sintaxis de desestructuración equivalente. Todavía deben seguir asignando las variables today y tomorrow con los valores de today y tomorrow del objeto HIGH_TEMPERATURES.
-----------------
¡Prístina Luna, dame el poder!
----------------
Usa sintaxis de desestructuración para asignar variables desde objetos
La desestructuración te permite asignar un nuevo nombre de variable al extraer valores. Puedes hacer esto al poner el nuevo nombre después de dos puntos al asignar el valor.

Usando el mismo objeto del ejemplo anterior:

const user = { name: 'John Doe', age: 34 };
Así es como puedes dar nuevos nombres de variables en la asignación:

const { name: userName, age: userAge } = user;
Puedes leerlo como "obtén el valor de user.name y asígnalo a una nueva variable llamada userName" y así sucesivamente. El valor de userName sería la cadena John Doe, y el valor de userAge sería el número 34.

Reemplaza las dos asignaciones con una sintaxis de desestructuración equivalente. Todavía deben seguir asignando las variables highToday y highTomorrow con los valores de today y tomorrow del objeto HIGH_TEMPERATURES.
------------------
freeCodeCamp Challenge Guide: Use Destructuring Assignment to Assign Variables from Objects
Guide

camperbot
Great contributor

1
Oct '19
Use Destructuring Assignment to Assign Variables from Objects 405
Solutions
Solution 1 (Click to Show/Hide)
const HIGH_TEMPERATURES = {
  yesterday: 75,
  today: 77,
  tomorrow: 80
};

// change code below this line
  
const { today: highToday, tomorrow: highTomorrow } = HIGH_TEMPERATURES;

// change code above this line

console.log(highToday); // should be 77
console.log(highTomorrow); // should be 80
-----------
¡Ríe y el mundo reirá contigo!
-----------
Usa sintaxis de desestructuración para asignar variables desde objetos anidados
Puedes usar los mismos principios de las dos lecciones anteriores para desestructurar los valores desde objetos anidados.

Usando un objeto similar a los ejemplos anteriores:

const user = {
  johnDoe: { 
    age: 34,
    email: 'johnDoe@freeCodeCamp.com'
  }
};
Así es como se extraen los valores de propiedades de objetos y se los asigna a variables con el mismo nombre:

const { johnDoe: { age, email }} = user;
Y así es como se puede asignar los valores de las propiedades de un objeto a variables con diferentes nombres:

const { johnDoe: { age: userAge, email: userEmail }} = user;
Reemplaza las dos asignaciones con una sintaxis de desestructuración equivalente. Todavía deben seguir asignando las variables lowToday y highToday con los valores de today.low y today.high del objeto LOCAL_FORECAST.

ANUNCIO PUBLICITARIO
--------------------------------
Guía del desafío freeCodeCamp: use la asignación de desestructuración para asignar variables de objetos anidados
Guía

autocaravana
Gran colaborador

3
12 de febrero
Utilice la asignación de desestructuración para asignar variables de objetos anidados 218
Sugerencias
Pista 1
Este desafío requiere que asigne valores de propiedad de objeto a variables de diferentes nombres.

Pista 2
Las dos líneas que declaran lowTodayy highTodayse pueden reemplazar con una sola línea que maneja ambos valores.

Soluciones
Solución 1 (haga clic para mostrar/ocultar)
const LOCAL_FORECAST = {
  yesterday: { low: 61, high: 75 },
  today: { low: 64, high: 77 },
  tomorrow: { low: 68, high: 80 }
};

// Only change code below this line
const { today: { low: lowToday, high: highToday } } = LOCAL_FORECAST;
// Only change code above this line
----------
¡Fuera de serie!
----------
Usa sintaxis de desestructuración para asignar variables desde arreglos
ES6 hace que desestructurar arreglos sea tan fácil como desestructurar objetos.

Una diferencia clave entre el operador de propagación y la desestructuración de arreglos es que el operador de propagación desempaca todos los contenidos de un arreglo en una lista separada por comas. En consecuencia, no puedes elegir qué elementos deseas asignar como variables.

Desestructurar un arreglo nos permite hacer exactamente eso:

const [a, b] = [1, 2, 3, 4, 5, 6];
console.log(a, b);
La consola mostrará los valores de a y b como 1, 2.

A la variable a se le asigna el primer valor del arreglo, y a b se le asigna el segundo valor del arreglo. También podemos acceder al valor en cualquier índice de un arreglo con la desestructuración usando comas para alcanzar el índice deseado:

const [a, b,,, c] = [1, 2, 3, 4, 5, 6];
console.log(a, b, c);
La consola mostrará los valores de a, b, y c como 1, 2, 5.

Utiliza la sintaxis de desestructuración para intercambiar los valores de a y b para que a reciba el valor almacenado en b, y b reciba el valor almacenado en a.
----------
Guía del desafío freeCodeCamp: use la asignación de desestructuración para asignar variables de matrices
Guía

autocaravana
Gran colaborador

3
dic '19
Utilice la asignación de desestructuración para asignar variables de matrices 867
Sugerencias
Pista # 1
Tenemos que tomar algunas precauciones en este caso.

No intente volver a declarar a o b durante la desestructuración, ya que ya están declarados en la primera letdeclaración.
Soluciones
Solución 1 (haga clic para mostrar/ocultar)
let a = 8, b = 6;
[a, b] = [b, a];
corazón
+1
139


La mejor forma de aprender es enseñando.
Regístrese para que pueda hacer preguntas y responder las preguntas de otras personas aquí. Esto lo ayudará a solidificar su propio conocimiento, todo mientras ayuda a otras personas en todo el mundo.
------------
¡Tienes agallas!
-----------
Las variables a y b toman el primer y segundo valor del arreglo. Después de eso, debido a la presencia del parámetro rest, arr obtiene el resto de los valores en forma de un arreglo. El elemento rest sólo funciona correctamente como la última variable en la lista. Por ejemplo, no puedes usar el parámetro rest para capturar un sub-arreglo que deje fuera el último elemento del arreglo original.

Utiliza la sintaxis de desestructuración con el parámetro rest para realizar un Array.prototype.slice() eficaz, de tal manera que arr sea un sub-arreglo del arreglo original source con los dos primeros elementos omitidos.
-----------
Guía del desafío freeCodeCamp: use la asignación de desestructuración con el parámetro Rest para reasignar elementos de matriz
Guía

autocaravana
Gran colaborador

1
octubre '19
Utilice la asignación de desestructuración con el parámetro Rest para reasignar elementos de matriz 225
Problema Explicación
Recuerde que el parámetro rest permite un número variable de argumentos. En este desafío, debes deshacerte de los dos primeros elementos de una matriz.

Sugerencias
Pista 1
Asigne los dos primeros elementos a dos variables aleatorias.

Pista 2
Establezca la parte restante de la matriz en ...arr.

Pista 3
Utilice la desestructuración para crear la arrvariable:

function removeFirstTwo(list) {
  "use strict";
  // change code below this line
  const [arr] = list; // change this
  // change code above this line
  return arr;
}
Pista 4:
Distribuya los listvalores de los parámetros en arr.

function removeFirstTwo(list) {
  "use strict";
  // change code below this line
  const [...arr] = list; // change this
  // change code above this line
  return arr;
}
Puede utilizar variables aleatorias para omitir los dos primeros valores:

Soluciones
Solución 1 (haga clic para mostrar/ocultar)
const source = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10];
function removeFirstTwo(list) {
  "use strict";
  // change code below this line
  const [a, b, ...arr] = list;
  // change code above this line
  return arr;
}
const arr = removeFirstTwo(source);
console.log(arr); // should be [3,4,5,6,7,8,9,10]
console.log(source); // should be [1,2,3,4,5,6,7,8,9,10];
También puede excluir los primeros dos elementos de la arrmatriz usando ,,.

Enlaces relevantes
“Asignación de desestructuración” - Referencia de MDN JavaScript 779
corazón
+1
45


La mejor forma de aprender es enseñando.
Regístrese para que pueda hacer preguntas y responder las preguntas de otras personas aquí. Esto lo ayudará a solidificar su propio conocimiento, todo mientras ayuda a otras personas en todo el mundo.
--------------
¡Sabíamos que lo lograrías!
-------------
Utiliza sintaxis de desestructuración para pasar un objeto como parámetro de función
En algunos casos, se puede desestructurar el objeto en un propio argumento de función.

Considera el siguiente código:

const profileUpdate = (profileData) => {
  const { name, age, nationality, location } = profileData;

}
Esto desestructura efectivamente el objeto enviado a la función. Esto también se puede hacer en el lugar:

const profileUpdate = ({ name, age, nationality, location }) => {

}
Cuando profileData es pasado a la función anterior, los valores son desestructurados desde el parámetro de función para su uso dentro de la función.

Utiliza la sintaxis de desestructuración dentro del argumento de la función half para enviar solo max y min dentro de la función.
----------
Guía del desafío freeCodeCamp: use la asignación de desestructuración para pasar un objeto como parámetro de una función
Guía

autocaravana
Gran colaborador

4
Jan '21
Usar asignación de desestructuración para pasar un objeto como parámetro de una función 673
Problema Explicación
Puede pasar el objeto completo y luego seleccionar los atributos específicos que desea mediante el .operador. ¡Pero ES6 ofrece una opción más elegante!

Sugerencias
Pista 1
Deshazte del stats, y ve si puedes desestructurarlo. Necesitamos el maxy minde stats.

Soluciones
Solución 1 (haga clic para mostrar/ocultar)
const stats = {
  max: 56.78,
  standard_deviation: 4.34,
  median: 34.54,
  mode: 23.87,
  min: -0.75,
  average: 35.85
};

// Only change code below this line
const half = ({ max, min }) => (max + min) / 2.0;
// Only change code above this line
Código Explicación
Note que estamos desestructurando statspara pasar dos de sus atributos - maxy min- a la función. No olvide modificar la segunda declaración de devolución. Cambie stats.maxa solo maxy cambie stats.mina solo min.
-------------
¡Ríe y el mundo reirá contigo!
-------------
Crea cadenas usando plantillas literales
Una nueva característica de ES6 es la plantilla literal. Este es un tipo especial de cadena que facilita la creación de cadenas complejas.

Las plantillas literales te permiten crear cadenas multilínea y usar características de interpolación, para crearlas.

Fíjese en el código debajo:

const person = {
  name: "Zodiac Hasbro",
  age: 56
};

const greeting = `Hello, my name is ${person.name}!
I am ${person.age} years old.`;

console.log(greeting);
La consola mostrará las cadenas Hello, my name is Zodiac Hasbro! y I am 56 years old..

Muchas cosas han ocurrido allí. En primer lugar, el ejemplo utiliza backticks (`), no comillas (' o "), para envolver la cadena. En segundo lugar, observe que la cadena es multi-línea tanto en el código como cuando se imprime en pantalla. Esto guarda la inserción \n dentro de las cadenas. La sintaxis ${variable} utilizada anteriormente es un marcador de posición. Básicamente, ya no tendrás que utilizar concatenación con el operador +. Para añadir variables a las cadenas, basta con colocar la variable en una plantilla de cadena y envolverla con ${ y }. Del mismo modo, puedes incluir otras expresiones en tu literal de cadena, por ejemplo ${a + b}. Esta nueva forma de crear cadenas te da mayor flexibilidad para crear cadenas robustas.

Usa la sintaxis de plantilla literal con comillas invertidas para crear un arreglo de cadenas de elemento lista (li). El texto de cada elemento de lista debe ser uno de los elementos del arreglo de la propiedad failure en el objeto result y tener un atributo class con el valor text-warning. La función makeList debe devolver el arreglo de cadenas de elemento lista.

Utiliza un método de iteración (cualquier tipo de bucle) para obtener el resultado deseado (mostrado a continuación).

[
  '<li class="text-warning">no-var</li>',
  '<li class="text-warning">var-on-top</li>',
  '<li class="text-warning">linebreak</li>'
]
----------
Guía del desafío freeCodeCamp: crear cadenas usando literales de plantilla
Guía

autocaravana
Gran colaborador

7
Sep '20
Crear cadenas usando literales de plantilla 668
Problema Explicación
En lugar de utilizar la concatenación de cadenas, ES6 ofrece literales de plantilla para crear cadenas. En este desafío, debe usar literales de plantilla para crear una serie de advertencias de texto.

Es necesario usar literales de plantilla para devolver una lista, ya que cada elemento de la matriz se envolverá en una <li></li>etiqueta.

Sugerencias
Pista 1
Iterar a través de cada elemento de arry agregar un nuevo elemento compuesto por un literal de plantilla utilizando arrlos elementos de para crear la matriz failureItems.
Soluciones
Solución 1 (haga clic para mostrar/ocultar)
const result = {
  success: ["max-length", "no-amd", "prefer-arrow-functions"],
  failure: ["no-var", "var-on-top", "linebreak"],
  skipped: ["no-extra-semi", "no-dup-keys"]
};
function makeList(arr) {
  "use strict";
  // change code below this line
  const failureItems = [];
  for (let i = 0; i < arr.length; i++) {
    failureItems.push(`<li class="text-warning">${arr[i]}</li>`);
  }
  // change code above this line
  return failureItems;
}

const failuresList = makeList(result.failure);
Solución 2 (haga clic para mostrar/ocultar)
const result = {
  success: ["max-length", "no-amd", "prefer-arrow-functions"],
  failure: ["no-var", "var-on-top", "linebreak"],
  skipped: ["no-extra-semi", "no-dup-keys"]
};
function makeList(arr) {
  "use strict";
  // change code below this line
  const failureItems = arr.map(item => `<li class="text-warning">${item}</li>`);
  // change code above this line
  return failureItems;
}
const failuresList = makeList(result.failure);

corazón
+1
reír
131


La mejor forma de aprender es enseñando.
-----------
¡Nunca bajes la guardia!
------------Escribe declaraciones concisas de objecto literales usando la abreviatura de propiedad de objeto
ES6 añade un buen soporte para definir fácilmente objetos literales.

Considera el siguiente código:

const getMousePosition = (x, y) => ({
  x: x,
  y: y
});
getMousePosition es una función simple que devuelve un objeto que contiene dos propiedades. ES6 proporciona el azúcar sintáctico para eliminar la redundancia de tener que escribir x: x. Puedes simplemente escribir x una vez, y se convertirá en x: x (o algo equivalente) de la nada. Aquí está la misma función de arriba reescrita para usar esta nueva sintaxis:

const getMousePosition = (x, y) => ({ x, y });
Utiliza la abreviatura de propiedad de objeto con objetos literales para crear y devolver un objeto con las propiedades name, age y gender.
------------
¿Qué clase de brujería es esta?
------------
ES6
Escribe funciones breves y declarativas con ES6
Al definir funciones dentro de objetos en ES5, tenemos que utilizar la palabra clave function de la siguiente manera:

const person = {
  name: "Taylor",
  sayHello: function() {
    return `Hello! My name is ${this.name}.`;
  }
};
Con ES6, puedes eliminar la palabra clave function y los dos puntos al definir funciones en objetos. Aquí hay un ejemplo de esta sintaxis:

const person = {
  name: "Taylor",
  sayHello() {
    return `Hello! My name is ${this.name}.`;
  }
};
Refactoriza la función setGear dentro del objeto bicycle para que utilice la sintaxis abreviada descrita arriba.ES6
Escribe funciones breves y declarativas con ES6
Al definir funciones dentro de objetos en ES5, tenemos que utilizar la palabra clave function de la siguiente manera:

const person = {
  name: "Taylor",
  sayHello: function() {
    return `Hello! My name is ${this.name}.`;
  }
};
Con ES6, puedes eliminar la palabra clave function y los dos puntos al definir funciones en objetos. Aquí hay un ejemplo de esta sintaxis:

const person = {
  name: "Taylor",
  sayHello() {
    return `Hello! My name is ${this.name}.`;
  }
};
Refactoriza la función setGear dentro del objeto bicycle para que utilice la sintaxis abreviada descrita arriba.
--------------
¡Tienes agallas!
---------------
Usa sintaxis de clases para definir una función constructora
ES6 proporciona una nueva sintaxis para crear objetos, usando la palabra clave class.

Debemos notar que la sintaxis class es sólo sintaxis, y no una implementación completa basada en clases de un paradigma orientado a objetos, a diferencia de lenguajes como Java, Python, Ruby, etc.

En ES5, normalmente definimos una función constructor y usamos la palabra clave new para instanciar un objeto.

var SpaceShuttle = function(targetPlanet){
  this.targetPlanet = targetPlanet;
}
var zeus = new SpaceShuttle('Jupiter');
La sintaxis class simplemente reemplaza la creación de la función constructor:

class SpaceShuttle {
  constructor(targetPlanet) {
    this.targetPlanet = targetPlanet;
  }
}
const zeus = new SpaceShuttle('Jupiter');
Debe tenerse en cuenta que la palabra clave class declara una nueva función, a la cual se añade un constructor. Este constructor se invoca cuando new es llamado para crear un nuevo objeto.

Nota: UpperCamelCase debe ser utilizado por convención para nombres de clase en ES6, como SpaceShuttle fue usado arriba.

El método constructor es un método especial para crear e inicializar un objeto creado con una clase. Aprenderás más sobre ello en la sección de Programación Orientada a Objetos de la Certificación en Algoritmos de JavaScript y Estructuras de Datos.

Usa la palabra clave class y escribe un constructor para crear la clase Vegetable.

La clase Vegetable te permite crear un objeto vegetal con una propiedad name que es pasada al constructor.
----------------
¡Tienes el toque!
-----------------
Utiliza getters (accesores) y setters (mutadores) para controlar el acceso a un objeto
Puedes obtener valores de un objeto y establecer el valor de una propiedad dentro de un objeto.

Estas operaciones clásicamente se llaman getters y setters.

Las funciones getter están destinadas a simplemente devolver (get) el valor de la variable privada de un objeto al usuario sin que el usuario acceda directamente a la variable privada.

Las funciones setter están destinadas a modificar (set) el valor de la variable privada de un objeto basado en el valor pasado a la función setter. Este cambio podría implicar cálculos, o incluso sobrescribir completamente el valor anterior.

class Book {
  constructor(author) {
    this._author = author;
  }
  // getter
  get writer() {
    return this._author;
  }
  // setter
  set writer(updatedAuthor) {
    this._author = updatedAuthor;
  }
}
const novel = new Book('anonymous');
console.log(novel.writer);
novel.writer = 'newAuthor';
console.log(novel.writer);
La consola mostrará las cadenas anonymous y newAuthor.

Ten en cuenta la sintaxis usada para invocar el getter y el setter. Ni siquiera se ven como funciones. Los getter y los setter son importantes porque ocultan los detalles internos de la implementación.

Nota: Es convención preceder el nombre de una variable privada con un guión bajo (_). Sin embargo, la práctica en sí misma no hace una variable privada.

Utiliza la palabra clave class para crear una clase Thermostat. El constructor acepta una temperatura Fahrenheit.

En la clase, crea un getter para obtener la temperatura en Celsius y un setter para ajustar la temperatura en Celsius.

Recuerda que C = 5/9 * (F - 32) y F = C * 9.0 / 5 + 32 donde F es el valor de la temperatura en Fahrenheit y C es el valor de la misma temperatura en Celsius.

Nota: Cuando implementes esto, rastrearás la temperatura dentro de la clase en una escala, ya sea Fahrenheit o Celsius.

Este es el poder de un getter y un setter. Estás creando una API para otro usuario, que puede obtener el resultado correcto independientemente de cuál estés rastreando.

En otras palabras, estás abstrayendo los detalles de la implementación del usuario.
----------------
Use getters y setters para controlar el acceso a un objeto 1.1k
Problema Explicación
Getters y setters son partes críticas de una clase/objeto. Te permiten controlar sus atributos desde el exterior. Se volverán más prominentes cuando comience con la unidad de Programación Orientada a Objetos (¡próximamente!). Por ahora, este ejercicio le muestra cómo manipularlos con ES6.

Sugerencias
Pista 1
Cree la clase, Termostato. Vas a poner tu constructor, getter y setter aquí.

Pista 2
Dale al constructor un parámetro (que puedes nombrar como quieras). Establezca el parámetro en un atributo del mismo nombre. Recuerde, inicialmente está configurando las cosas en temperatura Fahrenheit.

Pista 3
Cree un método get que convierta el atributo Fahrenheit a Celsius. Usa la fórmula que te dieron.

Pista 4:
Cree un método set con el mismo nombre que el método get. Debe tener un parámetro que acepte temperatura Celsius. Conviértalo a Fahrenheit y configúrelo en el atributo.

Soluciones
Solución 1 (haga clic para mostrar/ocultar)
class Thermostat {
  constructor(fahrenheit) {
    this.fahrenheit = fahrenheit;
  }
  
  get temperature() {
    return (5 / 9) * (this.fahrenheit - 32);
  }
  
  set temperature(celsius) {
    this.fahrenheit = (celsius * 9.0) / 5 + 32;
  }
}
corazón
+1
aplaudir
220


La mejor forma de aprender es enseñando.
Regístrese para que pueda hacer preguntas y responder
-----------
¡Tienes una cita con el destino!
------------
Crea un módulo para scripts
En sus inicios, JavaScript comenzó desempeñando un pequeño rol, cuando la web estaba mayormente hecha en HTML. Hoy Javascript se ha vuelto gigante y algunos sitios web están casi completamente construidos con JavaScript. Con la finalidad de hacer JavaScript más modular, limpio y mantenible, ES6 introdujo una manera de compartir código fácilmente entre archivos JavaScript. Esto implica exportar partes de un archivo para usar en uno o más archivos, e importar las partes que necesitas donde las necesites. Para aprovechar esta funcionalidad, necesitas crear un script en tu documento HTML con un type de module. A continuación, te presentamos un ejemplo:

<script type="module" src="filename.js"></script>
Un script que utilice este module ahora podrá utilizar las caraterísticas import y export, sobre las que aprenderás en los próximos desafíos.

Agrega un script de tipo module al documento HTML y asígnale el archivo fuente index.js
--------------
¡Incluso Grumpy Cat lo aprueba!
---------------
Utiliza la exportación para compartir un bloque de código
Imagina un archivo llamado math_functions.js que contiene varias funciones relacionadas con operaciones matemáticas. Uno de ellos se almacena en una variable, add, que toma dos números y devuelve su suma. Quieres utilizar esta función en varios archivos JavaScript diferentes. Para compartirlo con estos otros archivos, primero debes usar export (exportarlo).

export const add = (x, y) => {
  return x + y;
}
Lo anterior es una forma común de exportar una sola función, pero puedes lograr lo mismo como esto:

const add = (x, y) => {
  return x + y;
}

export { add };
Cuando exportas una variable o función, puedes importarla en otro archivo y usarla sin tener que volver a escribir el código. Puedes exportar diferentes cosas al repartir el primer ejemplo para cada una de ellas si quieres exportar o al colocarlas en la declaración de exportación del segundo ejemplo. Por ejemplo:

export { add, subtract };
Hay dos funciones relacionadas con cadenas en el editor. Exporta ambos utilizando el método que elijas.
------------
Programa mucho y prospera
------------
Reutiliza código de JavaScript utilizando import
import te permite elegir qué partes de un archivo o módulo cargar. En la lección previa, los ejemplos exportaron add del archivo math_functions.js. Así es como puedes importarlo para utilizarlo en otro archivo:

import { add } from './math_functions.js';
Aquí, import encontrará add en math_functions.js, importa sólo esa función para que la uses, e ignora el resto. El ./, dice a import que busque el archivo math_functions.js en la misma carpeta que el archivo actual. La ruta relativa del archivo (./) y la extensión del archivo (.js), son requeridos cuando se utiliza import de esta manera.

Puedes importar más de un elemento del archivo, añadiéndolos en la declaración import de esta manera:

import { add, subtract } from './math_functions.js';
Agrega la declaración import apropiada que permita al archivo actual, usar las funciones uppercaseString y lowercaseString que exportaste de la lección previa. Estas funciones se encuentran en un archivo llamado string_functions.js, el cual está en el mismo directorio que el archivo actual.
---------
freeCodeCamp Challenge Guide: Reuse Javascript Code Using import
Guide

camperbot
Great contributor

1
Oct '19
Reuse Javascript Code Using import 111
Solutions
Solution 1 (Click to Show/Hide)
import { uppercaseString, lowercaseString } from './string_functions.js';
// add code above this line

uppercaseString("hello");
lowercaseString("WORLD!");
----------

ADVERTISEMENT

freeCodeCamp Challenge Guide: Reuse Javascript Code Using import
Guide

camperbot
Great contributor

1
Oct '19
Reuse Javascript Code Using import 111
Solutions
Solution 1 (Click to Show/Hide)
import { uppercaseString, lowercaseString } from './string_functions.js';
// add code above this line

uppercaseString("hello");
lowercaseString("WORLD!");
-----------
Use * para importar todo de un archivo
Supongamos que tienes un archivo y deseas importar todo su contenido en el archivo actual. Esto puede hacerse con la sintaxis import * as. Este es un ejemplo donde los contenidos de un archivo llamado math_functions.js son importados a un archivo dentro del mismo directorio:

import * as myMathModule from "./math_functions.js";
La anterior declaración import, crea un objeto llamado myMathModule. Esto es, sólo el nombre de una variable, puedes nombrarlo de cualquier manera. El objeto contiene todas las exportaciones de math_functions.js, así puedes acceder a las funciones, como haces con cualquier propiedad del objeto. A continuación puedes usar las funciones importadas add y subtract:

myMathModule.add(2,3);
myMathModule.subtract(5,3);
El código actual, requiere los contenidos del archivo: string_functions.js, ubicado en el mismo directorio que el archivo actual. Usa la sintaxis import * as, para importar todo del archivo, en un objeto llamado stringFunctions.
----------
¡Bingo!
-----------
Guía del desafío freeCodeCamp: use * para importar todo desde un archivo
Guía

autocaravana
Gran colaborador

2
Nov '19
Use * para importar todo desde un archivo 48
Problema Explicación
Si desea importar todo lo posible desde un archivo, utilice la import * as _ fromsintaxis proporcionada por ES6. ¡Eso es exactamente lo que tienes que hacer en este desafío!

Sugerencias
Pista 1
Completa los espacios en blanco: import * as objName from "file-name". Normalmente, puede ser creativo con su archivo objName, pero en este desafío, debe tener un nombre stringFunctionsy el nombre del archivo debe ser ./string_functions.js.

Soluciones
Solución 1 (haga clic para mostrar/ocultar)
import * as stringFunctions from "./string_functions.js";
// add code above this line

stringFunctions.uppercaseString("hello");
stringFunctions.lowercaseString("WORLD!");
-----------------
Crear un fallback de exportación con export default
En la lección export, aprendiste sobre la sintaxis conocida como named export. Esto te permitió hacer disponibles múltiples funciones y variables para usar en otros archivos.

Aquí hay otra sintaxis export que necesitas saber, conocida como export default. Usualmente utilizarás esta sintaxis, si es sólo un valor el que está siendo exportado desde un archivo. También es utilizado para crear valores fallback para un archivo o módulo.

A continuación hay ejemplos usando export default:

export default function add(x, y) {
  return x + y;
}

export default function(x, y) {
  return x + y;
}
La primera es una función nombrada, y la segunda es una función anónima.

Ya que export default es usado para declarar un valor fallback para un módulo o archivo, sólo puedes tener un valor que sea exportación por defecto en cada módulo o archivo. Además, no puedes usar export default con var, let, o const

La siguiente función debe ser el valor fallback para el módulo. Por favor, añade el código necesario para hacerlo.
-------------
Algoritmos de JavaScript y proyectos de estructuras de datos
--------------
¡Al batimóvil!
-------------
¡Eres un mago, Harry!
------------
¡La estás rompiendo!
------------
¡Velocidad ridícula!
-------------
¡Incluso Grumpy Cat lo aprueba!
-------------
Bien hecho. Acabas de completar JavaScript Algorithms and Data Structures Projects.
------------
¡Sabíamos que lo lograrías!
----------
Importa una exportación por defecto
En el último desafío, aprendiste sobre export default (exportación por defecto) y sus usos. Para importar una exportación por defecto, necesita utilizar la sintaxis import de manera diferente. En el siguiente ejemplo, add es la exportación por defecto del archivo math_functions.js. A continuación, cómo importarlo:

import add from "./math_functions.js";
La sintaxis difiere en un punto clave. El valor importado, add, no está rodeado por llaves ({}). add, aquí es simplemente un nombre de variable, para cualquiera que sea la exportación por defecto del archivo math_functions.js. Puedes utilizar cualquier nombre aquí, al importar un valor por defecto.

El siguiente código, importa como exportación por defecto, desde el archivo math_functions.js, encontrado en el mismo directorio que este archivo. Da a la importación el nombre de subtract.
-------------
freeCodeCamp Challenge Guide: Import a Default Export
Import a Default Export 26
Importing an export default is almost the same as importing a normal export; you just don’t need the curly braces to define the name of what you’re importing from the file!

Hints
Hint 1
Fill in the blanks: import _ from "file-name". Plug in your module’s name (which is subtract) into _, and put "math-functions" into "file-name".

Solutions
Solution 1 (Click to Show/Hide)
import subtract from "./math_functions.js";
// add code above this line

subtract(7,4);
----------
¡A buen paso dale prisa!
--------------
Crea una promesa de JavaScript
Una promesa en JavaScript es exactamente como suena, se utiliza para hacer una promesa de que harás algo, habitualmente de forma asíncrona. Cuando la tarea se completa, o cumples tu promesa o no la cumples. Promise es una función constructora, así que tu necesitas usar la palabra clave new para crear una. Recibe una función como su argumento, con dos parámetros: resolve y reject. Estos métodos se utilizan para determinar el resultado de la promesa. Su sintaxis se ve así:

const myPromise = new Promise((resolve, reject) => {

});
Crea una nueva promesa llamada makeServerRequest. Pásale una función con parámetros resolve y reject al constructor.
----------
¡Fuera de serie!
-----------
Cumpleta una promesa con "resolve" y "reject"
Una promesa tiene tres estados: pending, fulfilled, y rejected. La promesa que creaste en el último desafío está atascada en el estado pending porque no añadiste una forma de completar la promesa. Los parámetros resolve y reject enviados a "promise" como argumentos, son utilizados para hacer lo siguiente. resolve se utiliza cuando quieres que tu promesa tenga éxito, y reject se usa cuando quieres que falle. Estos son métodos que toman un argumento, como se ve a continuación.

const myPromise = new Promise((resolve, reject) => {
  if(condition here) {
    resolve("Promise was fulfilled");
  } else {
    reject("Promise was rejected");
  }
});
El ejemplo anterior utiliza cadenas como argumento de las funciones, pero podrían ser cualquier otra cosa. El argumento a menudo puede ser un objeto del cual utilizarás datos que mostrarás en tu sitio web o en otro lugar.

Haz una función promesa que maneje el éxito y el fallo. Si responseFromServer es true, llama al método resolve para completar satisfactoriamente la promesa. Pasa a resolve una cadena con el valor We got the data. Si responseFromServer es false, utiliza el método reject y devuelve la cadena: Data not received.
--------
¡Prístina Luna, dame el poder!
----------
Maneja una promesa cumplida usando then
Las promesas son muy útiles, cuando tu tienes un proceso que toma una cantidad de tiempo desconocida en tu código (algo asíncrono por ejemplo), a menudo una petición de servidor. Cuando tu haces una petición a un servidor, toma algo de tiempo, después de que termina, normalmente quieres hacer algo con la respuesta del servidor. Esto se puede lograr utilizando el método then. El método then, se ejecuta inmediatamente después de que tu promesa se cumple con resolve. A continuación un ejemplo:

myPromise.then(result => {

});
result viene con el argumento proporcionado al método resolve.

Añade el método then a tu promesa. Usa result como parámetro de tu función callback, asimismo imprime result en la consola.
-------------
¡Eres imparable!
----------------
Maneja una promesa rechazada usando catch
catch es el método utilizado cuando tu promesa ha sido rechazada. Se ejecuta inmediatamente, después de que se llama al método reject de una promesa. A continuación la sintaxis:

myPromise.catch(error => {

});
error es el argumento pasado al método reject.

Añade el método catch a tu promesa. Usa error como el parámetro de tu función callback e imprime error en la consola.
----------------
¡Con el volumen a 11!
-----------------
Bien hecho. Acabas de completar ES6.
------------------
Expresiones regulares
Expresiones regulares, a veces acortadas a "regex" o "regexp", son patrones que ayudan a los programadores a encontrar, buscar, y reemplazar texto. Las expresiones regulares son muy potentes, pero pueden ser difícil de leer porque usan caracteres especiales para hacer coincidencias más complejas y flexibles.

En este curso, aprenderás como usar caracteres especiales, grupos de captura, miradas positivas y negativas, así como otras técnicas para hacer coincidir cualquier texto que quieras.
-----------
Usa el método "test"
Las expresiones regulares se utilizan en lenguajes de programación para coincidir con partes de cadenas. Creas patrones para ayudarte a hacer esa coincidencia.

Si quieres encontrar la palabra the en la cadena The dog chased the cat, puedes utilizar la siguiente expresión regular: /the/. Ten en cuenta que las comillas no son requeridas dentro de la expresión regular.

JavaScript tiene múltiples formas de usar expresiones regulares. Una forma de probar una expresión regular es usando el método .test(). El método .test() toma la expresión regular, la aplica a una cadena (que se coloca dentro de los paréntesis), y devuelve true o false si tu patrón encuentra algo o no.

let testStr = "freeCodeCamp";
let testRegex = /Code/;
testRegex.test(testStr);
El método test aquí devuelve true.

Aplica la expresión regular myRegex en la cadena myString usando el método .test().
----------------
¡Con calma y a codificar!
---------------
Haz coincidir cadenas literales
En el desafío anterior, buscaste la palabra Hello usando la expresión regular /Hello/. Esa expresión regular buscó una coincidencia literal de la cadena Hello. Aquí hay otro ejemplo donde se busca una coincidencia literal de la cadena Kevin:

let testStr = "Hello, my name is Kevin.";
let testRegex = /Kevin/;
testRegex.test(testStr);
Esta llamada a test devolverá true.

Cualquier otra variante de Kevin no coincidirá. Por ejemplo, la expresión regular /Kevin/ no coincidirá con kevin o KEVIN.

let wrongRegex = /kevin/;
wrongRegex.test(testStr);
Esta llamada a test devolverá false.

Un futuro desafío también mostrará cómo coincidir esas otras variantes.

Completa la expresión regular waldoRegex para encontrar "Waldo" en la cadena waldoIsHiding con una coincidencia literal.
-----------
¡Es el momento perfecto para ser histérico!
-----------
Coincide una cadena literal con diferentes posibilidades
Al utilizar expresiones regulares como /coding/, puedes buscar el patrón coding en otra cadena.

Esto es muy potente al buscar cadenas individuales, pero está limitado a un solo patrón. Puedes buscar múltiples patrones usando el operador alternation o OR: |.

Este operador coincide con los patrones antes o después de él. Por ejemplo, si deseas coincidir con las cadenas yes o no, la expresión regular que quieres es /yes|no/.

También puedes buscar más de dos patrones. Puedes hacer esto añadiendo más patrones con más operadores OR separándolos, como /yes|no|maybe/.

Completa la expresión regular petRegex para que coincida con las mascotas dog, cat, bird, o fish.
----------------
¡Al batimóvil!
---------------
Ignora la capitalización al coincidir
Hasta ahora, has visto expresiones regulares para hacer coincidir cadenas literales. Pero a veces, tal vez quieras hacer coincidir las diferencias de capitalización.

La capitalización (o también llamada capitalización de letra) es la diferencia entre mayúsculas y minúsculas. Ejemplos de mayúsculas son A, B y C. Ejemplos de minúsculas son a, b y c.

Puedes coincidir ambos casos utilizando algo llamado bandera. Existen otras banderas, pero aquí te centrarás en la que ignora la capitalización de las letras, la bandera i. Puedes usarla añadiéndola a la expresión regular. Un ejemplo de uso de esta bandera es /ignorecase/i. Esta expresión regular puede coincidir con las cadenas ignorecase, igNoreCase e IgnoreCase.

Escribe una expresión regular fccRegex para que coincida con freeCodeCamp sin importar su capitalización. Tu expresión regular no debe coincidir con ninguna abreviatura o variación con espacios.
------------
let myString = "freeCodeCamp";
let fccRegex = /freeCodeCamp/i; // Cambia esta línea
let result = fccRegex.test(myString);
-----------
¡Con el volumen a 11!
------------
Extrae coincidencias
Hasta ahora, sólo has estado comprobando si un patrón existe o no dentro de una cadena. También puedes extraer las coincidencias encontradas con el método .match().

Para utilizar el método .match(), aplica el método a una cadena y pasa la expresión regular dentro de los paréntesis.

Este es un ejemplo:

"Hello, World!".match(/Hello/);
let ourStr = "Regular expressions";
let ourRegex = /expressions/;
ourStr.match(ourRegex);
Aquí el primer match devolverá ["Hello"] y el segundo devolverá ["expressions"].

Ten en cuenta que la sintaxis .match es lo "opuesto" al método .test que has estado utilizando hasta ahora:

'string'.match(/regex/);
/regex/.test('string');
Aplica el método .match() para extraer la cadena coding.
------------
Extraer coincidencias 18
Problema Explicación
Con el match()método, puede extraer partes de una cadena que coincidan con su expresión regular. En este desafío, está extrayendo la palabra "codificación" de la cadena provista.

Sugerencias
Pista 1
Cambie su expresión regular para detectar la palabra "codificación".

Pista 2
¿Llamaste al match()método en la cadena?

Soluciones
Solución 1 (haga clic para mostrar/ocultar)
let extractStr = "Extract the word 'coding' from this string.";
let codingRegex = /coding/;
let result = extractStr.match(codingRegex);

La mejor forma de aprender es enseñando.
-------------------
¡Una para los Récords Guinness!
-----------------
Encuentra más que la primera coincidencia
Hasta ahora, sólo has podido extraer o buscar un patrón una vez.

let testStr = "Repeat, Repeat, Repeat";
let ourRegex = /Repeat/;
testStr.match(ourRegex);
Aquí match devolverá ["Repeat"].

Para buscar o extraer un patrón más de una vez, puedes utilizar la bandera g.

let repeatRegex = /Repeat/g;
testStr.match(repeatRegex);
Y aquí match devuelve el valor ["Repeat", "Repeat", "Repeat"]

Utilizando la expresión regular starRegex, encuentra y extrae ambas palabras Twinkle de la cadena twinkleStar.

Nota
En tu expresión regular puedes utilizar múltiples banderas, como /search/gi
-----------------
let twinkleStar = "Twinkle, twinkle, little star";
let starRegex = /Twinkle/gi; // Cambia esta línea
let result = twinkleStar.match( starRegex); // Cambia esta línea
-------------
¡Eres lo máximo!
----------------
Haz coincidir cualquier cosa con el comodín punto
A veces no conoces (o no necesitas conocer) los caracteres exactos en tus patrones. Pensar en todas las palabras que coincidan, digamos, con una ortografía errónea llevaría mucho tiempo. Afortunadamente, puedes ahorrar tiempo utilizando el carácter de comodín: .

El carácter de comodín . coincidirá con cualquier carácter único. El comodín también es llamado dot y period. Puedes utilizar el carácter de comodín como cualquier otro carácter en la expresión regular. Por ejemplo, si quieres hacer coincidir hug, huh, hut, y hum, puedes usar la la expresión regular /hu./ para que coincida con las cuatro palabras.

let humStr = "I'll hum a song";
let hugStr = "Bear hug";
let huRegex = /hu./;
huRegex.test(humStr);
huRegex.test(hugStr);
Ambas llamadas a test devolverán true.

Completa la expresión regular unRegex para que coincida con las cadenas run, sun, fun, pun, nun, y bun. Tu expresión regular debe usar el carácter de comodín
------------
Guía del desafío freeCodeCamp: haga coincidir cualquier cosa con el período comodín
Guía

autocaravana
Gran colaborador

1
octubre '19
Hacer coincidir cualquier cosa con el período comodín 26
Sugerencias
Pista 1
El punto .es la clave en este desafío.

Pista 2
Debes poner el punto en la posición correcta.

Soluciones
Solución 1 (haga clic para mostrar/ocultar)
let exampleStr = "Let's have fun with regular expressions!";
let unRegex = /.un/; // Change this line
let result = unRegex.test(exampleStr);
Código Explicación
El punto .será cualquier carácter, por lo que las cadenas "run", "sun", "fun" y "pun" tienen los mismos caracteres.

La mejor forma de aprender es enseñando.
-----------------
let exampleStr = "Let's have fun with regular expressions!";
let unRegex = /.un/; // Cambia esta línea
let result = unRegex.test(exampleStr);
-------------
¡Sabíamos que lo lograrías!
-----------
Haz coincidir un solo carácter con múltiples posibilidades
Aprendiste cómo hacer coincidir los patrones literales (/literal/) y el carácter de comodín (/./). Estos son los extremos de las expresiones regulares, donde uno encuentra coincidencias exactas y el otro coincide de todo. Hay opciones que representan un equilibrio entre los dos extremos.

Puedes buscar un patrón literal con cierta flexibilidad utilizando las clases de caracteres. Las clases de caracteres te permiten definir un grupo de caracteres que deseas coincidir colocándolos dentro de corchetes ([ y ]).

Por ejemplo, si quieres hacer coincidir bag, big, y bug pero no bog. Puedes crear la expresión regular /b[aiu]g/ para hacer esto. [aiu] es la clase de caracteres que solo coincidirá con los caracteres a, i, o u.

let bigStr = "big";
let bagStr = "bag";
let bugStr = "bug";
let bogStr = "bog";
let bgRegex = /b[aiu]g/;
bigStr.match(bgRegex);
bagStr.match(bgRegex);
bugStr.match(bgRegex);
bogStr.match(bgRegex);
En orden, las cuatro llamadas de match devolverán los valores ["big"], ["bag"], ["bug"], and null.

Usa una clase de caracteres con las vocales (a, e, i, o u) en tu expresión regular vowelRegex para encontrar todas las vocales en la cadena quoteSample.

Nota: Asegúrate de hacer coincidir tanto las vocales mayúsculas como minúsculas.
--------------